[ { "title": "안녕하세요! 71stars 블로그입니다", "url": "/blog/introduction/2025/08/20/hello-world.html", "categories": "blog, introduction", "tags": "", "date": "2025-08-20 12:00:00 +0900", "content": "안녕하세요! 71stars 블로그에 오신 것을 환영합니다! 🚀 소개 이 블로그는 AI와 자동화의 만남을 다루는 블로그입니다. 주요 내용 AI 기술 동향 자동화 프로젝트 개발 일지 기술 리뷰 기술 스택 프론트엔드: HTML, CSS, JavaScript 백엔드: Spring Boot, Node.js AI/ML: Python, TensorFlow, PyTorch 자동화: GitHub Actions, CI/CD 앞으로 많은 내용으로 찾아뵙겠습니다! 😊 " }, { "title": "20250804 Spring Boot + Vue 프로젝트 회고록", "url": "/jekyll/update/2025/08/04/20250804-Spring-Boot-Vue-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%9A%8C%EA%B3%A0%EB%A1%9D.html", "categories": "jekyll, update", "tags": "", "date": "2025-08-04 12:57:40 +0900", "content": "Spring Boot + Vue 프로젝트 회고록– 에러 로그, AI 도구, 그리고 나의 성장 에러 로그와 함께 성장한 3일이번 사이드 프로젝트에서는 Spring Boot와 Vue.js를 붙여서 기자단 캠페인 플랫폼을 만들었다.간단한 CRUD만 구현하면 되는 줄 알았지만, 막상 붙여보니 예상치 못한 에러들이 계속 터졌다.처음 겪는 에러도 많았고, 설정 꼬임도 잦았다.이번 회고는 그런 문제들을 어떻게 해결했는지, 그리고 Cursor AI와 Gemini CLI 같은 AI 도구를 사용하면서 어떤 경험을 했는지를 함께 정리한 기록이다. Previous image Next image 프로젝트 구프론트엔드: Vue 3 (Vite + Axios)백엔드: Spring Boot 3.xDB: H2 (개발용)인증: JWT빌드 시스템: Maven → Gradle 전환사용 툴: Cursor AI, Gemini CLI, ChatGPT 개발 중 겪은 주요 이슈들1. Maven 플러그인 인식 안 됨처음 프로젝트를 Maven으로 시작했는데, 아래 같은 에러가 발생했다. No plugin found for prefix ‘spring-boot’ No plugin found for prefix ‘spring-boot’결론은 pom.xml에 실수로 잘못된 태그가 들어 있었던 것. Maven은 XML 문법이 틀리면 조용히 빌드가 안 되기 때문에 찾는 데 시간이 걸렸다.파일을 새로 작성하면서 해결했는데, 이때부터 “Gradle로 바꿔야겠다”는 생각이 슬슬 들기 시작했다. 8080 포트 충돌 Port 8080 was already in use 이건 자바 프로세스가 꺼지지 않아서 발생했다. PowerShell에서 다음 명령어로 해결했다. Get-Process java Stop-Process -Force 로그인 403 (Forbidden)로그인 API를 호출했는데 계속 403이 떴다.JWT 필터가 모든 요청에 적용되면서, 로그인 요청까지 막아버리고 있었다.Security 설정에서 로그인과 회원가입 관련 URI만 필터에서 제외시켜서 해결. ECONNREFUSED – 프론트와 백 연결 실패 원인: 주소 문제프론트가 백엔드에 요청을 보냈는데,IPv6 주소인 ::1:8080으로 보내고 있었고, 백엔드는 IPv4만 리스닝하고 있어서 연결이 안 됐다. connect ECONNREFUSED ::1:8080 백엔드 설정에서 address를 0.0.0.0으로 열고,프론트 proxy 주소를 127.0.0.1로 변경해서 해결했다. 로그인 계정 오류처음엔 admin@example.com으로 로그인하려 했는데 안 됐다.확인해보니 실제로 DataInitializer.java에서 만들어진 계정은test@example.com / password123이었다.해당 계정으로 로그인하니 정상 작동했다. 캠페인 조회 시 500 에러캠페인 상세 페이지를 요청했더니 500 에러 발생.원인은 단순했다.ID=1 캠페인이 DB에 없었다.H2 콘솔에 접속해서 테이블 확인하고 수동으로 더미 데이터를 추가해서 해결했다. 이미지 로딩 실패 GET https://via.placeholder.com/300x200 net::ERR_NAME_NOT_RESOLVED 이미지 주소로 사용하던 placeholder.com이 막혀 있었고,대체로 picsum.photos를 사용하고, 로딩 실패 시 fallback 이미지로 처리했다. Cursor AI와 Gemini CLI 사용 후기Cursor AICursor는 IntelliJ보다 훨씬 가볍고, AI 코드 보조 기능이 강력하다.특히 에러 메시지를 복붙해서 코드 안에서 바로 답변 받는 기능이 굉장히 직관적이었다.대부분의 문법 오류나 설정 문제는 Cursor에서 바로 해결 실마리를 얻었다.장점: 빠른 피드백, 코드 컨텍스트 유지됨, Copilot보다 명확한 답변단점: 복잡한 설정 이슈(Spring Security나 JWT 인증 흐름)는 정확도 떨어짐 정리하자면, 코드 레벨 디버깅용으로는 최고.하지만 복잡한 백엔드 로직 구조 설계에는 추가 설명이 필요했다. Gemini CLIGemini CLI는 로컬 터미널 환경에서 빠르게 질문하고 결과를 볼 수 있다는 점이 장점이었다.간단한 개념 확인, 오류 코드 해석, config 파일 예시 요청 등에 유용했다.장점: CLI에 최적화, 짧은 명령어 기반, 개념 요약 빠름단점: 실시간 코드 맥락 이해력은 떨어짐 정리하자면, “도우미”로는 훌륭하지만, “전담 해결사”는 아님.Copilot이나 Cursor처럼 코드 문맥까지 고려한 처리는 부족했다. Gradle로 전환한 이유이 프로젝트에서 가장 잘한 결정 중 하나는 Maven에서 Gradle로 갈아탄 것이다.처음엔 익숙해서 Maven을 썼지만,의존성 버전 충돌 디버깅빌드 속도설정 유연성이 세 가지 면에서 Gradle이 훨씬 나았다.특히 build.gradle.kts로 구조를 잡으면서 설명하기 쉬운 빌드 구조를 만들 수 있었다.앞으로는 Gradle 기반으로 프로젝트를 시작할 계획이다. 지금 상태 점검백엔드: Gradle 기반으로 정상 기동프론트–백 연결: IPv4로 통일, 정상 작동JWT 로그인: 정상 작동캠페인 상세 조회: 데이터 없을 경우 예외 처리 필요이미지: fallback 적용했으나 여전히 placeholder 문제 있음 느낀 점 &amp; 회고이번 프로젝트는 에러에 부딪히는 시간이 대부분이었다.근데 그만큼 설정 파일 하나, 필터 한 줄, 포트 번호 하나가 시스템 전체를 막을 수 있다는 걸 제대로 체감했다.또, 처음에는 에러가 생기면 일단 검색부터 했지만,이번엔 Cursor AI나 Gemini CLI를 써서 빠르게 로그를 해석하고 실험적으로 시도할 수 있었다.AI가 모든 걸 해결해주는 건 아니었지만, 반복적인 디버깅 시간을 확실히 줄여준 건 맞다. “내가 직접 문제를 해결하는 느낌은 살리고, 불필요한 구글링은 덜고”이게 이번 프로젝트에서 AI 도구를 쓰며 가장 만족스러웠던 부분이다. 다음 작업 목록캠페인 ID 조회 시 404로 graceful 처리기본 이미지 서버 자체적으로 구성JWT 인증 흐름 좀 더 명확히 정리Gradle 기반 멀티 모듈 구조 연습 이런 경험 하나하나가 쌓이면서,이제는 프로젝트보다 설정이 무섭지 않게 됐다.다음 프로젝트에선 더 빠르게 구조 잡고, 더 적은 에러로 개발할 수 있을 것 같다. " }, { "title": "⌨️하루하루 배우는 개발 공부, 그리고 아쉬움", "url": "/jekyll/update/2025/07/22/%ED%95%98%EB%A3%A8%ED%95%98%EB%A3%A8-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EA%B0%9C%EB%B0%9C-%EA%B3%B5%EB%B6%80-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%95%84%EC%89%AC%EC%9B%80.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-22 17:54:09 +0900", "content": "안녕하세요, 김기성입니다. 최근에는 취업 준비와 면접, 실무 테스트 준비로 정신없이 바쁜 나날을 보내고 있습니다.원래는 매일매일 블로그에 기술 스택과 공부한 내용을 정리해서 올리겠다고 다짐했었는데,막상 바쁘다 보니 ‘그냥 올리는 데 의미를 두자’라는 생각으로, GPT가 작성해 준 내용을 복붙하는 수준에 머무른 것 같아 아쉬움이 남습니다.하지만 기쁘게도, 최근 한 회사에서 저를 좋게 봐 주셔서 내일부터 3개월간 인턴을 시작하게 되었습니다.아직 확신이 서서 결정된 것은 아니지만, 기회를 주고 싶다고 말씀해 주셔서 너무 감사했습니다. ✅ TypeScript - infer 키워드​infer는 타입스크립트에서 조건부 타입 안에서 특정 타입을 추론할 때 사용됩니다.독립적으로는 쓸 수 없고, 반드시 extends와 함께 사용해야 합니다.예시: type GetReturnType = T extends (...args: any[]) =&gt; infer R ? R : never; 이렇게 하면 함수의 반환 타입을 R로 추론해 줍니다. ​출처: https://romantech.net/1238 ✅ @OneToOne Lazy Loading 주의점JPA에서 @OneToOne 관계를 맺고 fetch = LAZY를 지정해도, 연관관계의 주인이 아닌 쪽에서는 Lazy 로딩이 동작하지 않을 수 있습니다.이는 FK가 주인 엔티티에만 있기 때문에 발생하는 한계입니다.그래서 단방향으로 모델링하거나, Lazy가 정말 필요한지 다시 고민하는 것이 좋습니다. ​출처: https://codediary21.tistory.com/110 ✅ BFF(Backend For Frontend)BFF는 MSA 환경에서 클라이언트가 여러 API를 호출해야 하는 복잡함을 줄이기 위해 등장한 개념입니다.클라이언트별로 최적화된 데이터만 제공하는 백엔드 계층을 따로 두어, 웹/모바일/스마트TV 등에 맞게 데이터를 가공하고 효율을 높입니다.인증 처리, CORS 문제 해결 등도 맡을 수 있어 유용합니다. ​출처: https://medium.com/@elifcetineer/backend-for-frontend-bff-architecture-666bbdc3d5b1 ✅ IaC(Infrastructure as Code)코드로 인프라를 정의하고 배포하는 방식입니다.반복 작업을 줄이고, 형상 관리도 가능하며, 자동화가 쉽습니다.대표적인 도구로는 Terraform, CloudFormation, Ansible 등이 있습니다.단점은 러닝 커브와 디버깅의 어려움입니다. ​출처: https://radixweb.com/blog/what-is-infrastructure-as-code-and-its-best-practices ✅ Hibernate SQL 로그아래는 Hibernate로 User와 Account의 연관 관계를 Lazy로 조회할 때 찍힌 쿼리 예시입니다. select u1_0.id from users u1_0 where u1_0.id = ? select a1_0.user_id from account a1_0 where a1_0.user_id = ? @OneToOne 관계에서 Lazy 로딩이 걸리면 이렇게 SELECT 쿼리가 각각 실행됩니다.(참고: 연관관계 주인 쪽이 아니면 Lazy가 동작하지 않는 문제도 있습니다.) ​출처: https://gmoon92.github.io/spring/jpa/hibernate/n+1/2021/01/12/jpa-n-plus-one.html JPA 성능 N+1 문제와 해결 방법 Moon gmoon92.github.io ✨ 앞으로의 다짐‘매일’ 기록하는 것보다 중요한 건, 내가 직접 이해하고 경험한 것을 정리하는 것이라는 걸 느꼈습니다.앞으로는 느리더라도, 더 좋은 기록을 남길 수 있도록 노력하겠습니다.그리고 이번에 인턴 기회를 주신 만큼, 회사에 도움이 될 수 있도록 배우고 성장하며 최선을 다하겠습니다.아직 신입이고, 부족한 점이 많지만 너무 막 잘하려고 애쓰기보다는,혹여 실수를 하더라도 주눅들지 않고, 하루하루 배우며1인분은 아직 어렵더라도, 적어도 0.8인분을 할 수 있는 사람이 되도록 노력하겠습니다.오늘도 성장하는 하루가 되기를! 🌸 🎨 태그: #개발공부 #프로그래밍 #TypeScript #JPA #BFF #IaC #Hibernate #기록하는개발자 #인턴시작 #성장하는개발자 " }, { "title": "[매일매일]프론트 엔드 기술 일기: npm install과 npm ci의 차이점", "url": "/jekyll/update/2025/07/18/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%ED%94%84%EB%A1%A0%ED%8A%B8-%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-npm-install%EA%B3%BC-npm-ci%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-18 18:30:12 +0900", "content": "npm install과 npm ci(clean-install) 모두 의존성 목록을 설치하는 커맨드이지만, 세부 동작에 차이가 있습니다. 요약하면, npm ci는 npm install에 비해 의존성의 버전을 엄격하게 유지합니다.​첫째, npm install은 package.json에 명시된 version range 내에서 다른 버전을 설치할 가능성이 있지만, npm ci는 오직 package-lock.json에 정확하게 표기된 특정 버전을 따릅니다. 이로 인해 예기치 않게 다른 버전의 의존성을 설치하는 일을 방지합니다. 더불어 정확히 명시된 버전을 설치하므로 버전을 결정하기 위한 연산을 수행할 필요가 없어 설치 속도에서 유리한 측면이 있습니다.​둘째, npm install은 package-lock.json을 변경할 가능성이 있지만, npm ci는 절대 변경하지 않습니다. 이러한 특징으로 인해 npm ci는 의존성 목록의 버전을 변경없이 일관되게 유지할 수 있게 해줍니다.​셋째, npm ci는 매번 node_modules을 삭제한 후 설치합니다. 이를 통해 이전에 설치된 의존성과의 충돌로 인한 문제를 방지합니다. 또한, 오로지 package-lock.json에 따라서 매번 동일한 의존성을 설치할 것을 확실하게 보장합니다. 이러한 차이점들로 인해 npm ci는 CI/CD 환경에서 빌드 과정의 일관성을 보장하기 위한 목적으로 사용되는 경우가 많습니다.​npm ci를 로컬 개발 환경에서도 사용하면 안 되나요? 🤔가능합니다. 하지만 npm ci는 node_modules을 매번 모두 삭제하고 다시 설치하기 때문에 불필요한 시간이 소요될 수 있습니다. 따라서, 로컬에서는 일반적으로 npm install을 사용하고, CI/CD 환경에서는 npm ci를 사용하는 경우가 많습니다. 다만, 팀 내에서 의존성 버전을 엄격하게 맞추는 것이 중요하다고 판단되면 로컬 환경에서도 npm ci를 사용할 수 있습니다. " }, { "title": "[매일매일]백엔드 기술일기: String 객체가 불변인 이유/리터럴로 생성한 String 객체와 생성자로 생성한 String 객체의 차이", "url": "/jekyll/update/2025/07/18/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0%EC%9D%BC%EA%B8%B0-String-%EA%B0%9D%EC%B2%B4%EA%B0%80-%EB%B6%88%EB%B3%80%EC%9D%B8-%EC%9D%B4%EC%9C%A0-%EB%A6%AC%ED%84%B0%EB%9F%B4%EB%A1%9C-%EC%83%9D%EC%84%B1%ED%95%9C-String-%EA%B0%9D%EC%B2%B4%EC%99%80-%EC%83%9D%EC%84%B1%EC%9E%90%EB%A1%9C-%EC%83%9D%EC%84%B1%ED%95%9C-String-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EC%B0%A8%EC%9D%B4.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-18 18:12:45 +0900", "content": "String 객체는 불변(Immutable) 입니다. String 클래스는 내부적으로 final 키워드가 선언된 byte[] 필드를 사용해서 문자열을 저장하기 때문입니다. 또한, String은 참조 타입(Reference Type)이기 때문에 concat(), replace(), toUpperCase()와 같은 String 메서드를 호출하면 새로운 String 객체를 참조하고 기존 객체를 수정하지 않습니다. 따라서 String 객체를 불변하게 유지할 수 있습니다. ​String을 불변으로 설계한 이유는 무엇일까요?​String을 불변으로 설계한 덕분에 많은 이점을 얻을 수 있습니다.String Constant Pool을 사용할 수 있습니다. 이를 통해 동일한 문자열의 String 변수들은 같은 객체를 공유하기 때문에 메모리를 효율적으로 사용할 수 있습니다.불변한 객체는 멀티 스레드 환경에서 thread-safe합니다. 문자열을 변경하면 String Constant Pool에 새로운 객체를 생성하기 때문에 동기화를 신경쓸 필요가 없습니다.해시코드를 한 번만 계산하고 이를 캐싱해서 재사용할 수 있습니다.비밀번호, 토큰, URL 등의 민감한 정보를 안전하게 다룰 수 있습니다. 불변한 객체는 변경할 수 없기 때문에 민감한 정보가 예기치 않게 수정되는 것을 방지할 수 있습니다. 두 방식으로 생성한 객체는 같은 문자열을 갖더라도 메모리 상에서 다르게 처리됩니다. String first = “hello”; // 리터럴로 생성 String second = new String(“hello”); // 생성자로 생성 String third = “hello”; System.out.println(System.identityHashCode(first)); // 498931366 System.out.println(System.identityHashCode(second)); // 2060468723 System.out.println(System.identityHashCode(third)); // 498931366 리터럴로 생성한 String 객체는 Heap 영역의 String Constant Pool에 저장되어 동일한 문자열을 재사용할 수 있습니다. 문자열이 String Constant Pool에 이미 존재하면 같은 주소를 참조합니다. 반면, 생성자로 생성한 String 객체는 Heap 영역에 저장되어 동일한 문자열이더라도 항상 새로운 객체를 생성합니다. String first = “hello”; String second = new String(“hello”); String third = second.intern(); // intern() 메서드 사용 System.out.println(System.identityHashCode(first)); // 498931366 System.out.println(System.identityHashCode(second)); // 2060468723 System.out.println(System.identityHashCode(third)); // 498931366 intern() 메서드를 사용하면 Heap 영역에 저장된 String 객체를 String Constant Pool에 저장할 수 있습니다. intern() 메서드는 해당 문자열이 String Constant Pool에 존재할 경우 그 주솟값을 반환하고, 없을 경우 String Constant Pool에 추가하고 새로운 주솟값을 반환합니다. " }, { "title": "️[매일매일]프론트엔드 기술 일기: 인증과 인가, 그리고 나의 삽질기: JWT와 401 에러를 마주하며", "url": "/jekyll/update/2025/07/17/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-%EC%9D%B8%EC%A6%9D%EA%B3%BC-%EC%9D%B8%EA%B0%80-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%82%98%EC%9D%98-%EC%82%BD%EC%A7%88%EA%B8%B0-JWT%EC%99%80-401-%EC%97%90%EB%9F%AC%EB%A5%BC-%EB%A7%88%EC%A3%BC%ED%95%98%EB%A9%B0.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-17 13:29:29 +0900", "content": "“아니, 분명 로그인했는데 왜 또 401이야…” Greenwear 프로젝트를 진행하면서 가장 많이 마주쳤던 에러 중 하나가 바로 401 Unauthorized 였습니다.특히 로그인 API를 /api/login으로 호출하면서 시큐리티 에러와 JWT 토큰 관련 문제로 정말 골머리를 앓았던 기억이 나네요.더군다나 이 프로젝트에서는 Cursor AI, Gemini CLI 같은 AI 도구를 적극 활용했기 때문에 더 빠르게 개발할 수 있었지만, 동시에 중요한 부분을 당연한 것처럼 넘기거나 누락해 실수한 경우도 많았습니다.이번 글에서는 그때의 경험을 바탕으로 인증/인가 개념, 간단한 예제, 그리고 왜 AI를 써도 401을 맞았는지까지 정리해 보겠습니다. 📚 인증(Authentication)과 인가(Authorization)란?✅ 인증 (Authentication) ✅ 인가 (Authorization) 🔍 Greenwear 프로젝트에서의 삽질기🌱 Greenwear 프로젝트에서는 JWT를 활용한 로그인 인증을 구현했는데요, 초기에는 아래처럼만 생각했습니다: if (userId &amp;&amp; password) { return jwt.sign({ userId }, SECRET); } 로그인하면 토큰을 클라이언트에 주고, API 요청 시 헤더에 Authorization: Bearer 을 붙이는 구조였죠.그런데…로그인 후에도 계속 401 Unauthorized 에러.관리자 권한이 필요한 API에 일반 계정으로 접근해도 에러가 안 나는 문제.토큰 유효성 검증 누락으로 보안 취약점. 🚨 /api/login 삽질기특히 이 부분이 핵심이었어요.로그인 API 요청을 클라이언트에서 /api/login으로 보내면서, 백엔드에서는 /login만 처리하도록 구현해 둔 상태였습니다.결과:/login → 정상 동작/api/login → 401 혹은 404 이유는 2가지였습니다:1. 라우팅 불일치 app.post(“/login”, handler); 서버는 /login만 처리하는데, 클라이언트는 /api/login으로 요청 → 매칭 실패.2. 시큐리티 설정 문제​스프링 시큐리티 설정을 이렇게 해놨었습니다. .antMatchers(“/login”).permitAll() .antMatchers(“/api/**”).authenticated(); 즉, /api/** 경로는 인증을 요구했고, /api/login도 거기에 포함돼서 로그인조차 인증을 요구하는 웃픈 상황이 된 겁니다ㅎㅎ ^^ 🤖 AI를 쓰면 더 빨라지지만 더 위험할 수도 있다이 프로젝트에서는 빠른 개발을 위해 Cursor AI와 Gemini CLI를 적극 활용했습니다.코드 스니펫을 자동 완성해 주고,시큐리티 설정도 추천해 줬고,JWT 유틸 함수도 AI가 생성해줬습니다.개발 속도는 정말 빨랐습니다.하지만 문제는… “왜 API 요청 경로와 시큐리티 설정이 불일치하는데도 난 못 봤지?” AI가 작성해준 코드가 잘못된 건 아니지만, 제가 리뷰를 꼼꼼히 하지 않아 중요한 부분을 간과한 게 원인이었습니다.AI를 쓸수록 기본 개념을 알고 꼼꼼히 체크해야 한다는 교훈을 얻었습니다. 🧪 실습 예제: JWT로 인증 + 인가1️⃣ 인증 예제: 로그인 &amp; 토큰 발급 app.post(“/login”, (req, res) =&gt; { const { username, password } = req.body; if (username === “admin” &amp;&amp; password === “secret”) { const token = jwt.sign({ username, role: “admin” }, SECRET, { expiresIn: “1h” }); res.json({ token }); } else { res.status(401).send(“Invalid credentials”); } }); 2️⃣ 인가 예제: 권한 확인 const authMiddleware = (req, res, next) =&gt; { const token = req.headers.authorization?.split(“ “)[1]; if (!token) return res.status(401).send(“Unauthorized”); try { const decoded = jwt.verify(token, SECRET); req.user = decoded; next(); } catch { res.status(401).send(“Invalid token”); } }; app.get(“/admin”, authMiddleware, (req, res) =&gt; { if (req.user.role !== “admin”) { return res.status(403).send(“Forbidden: Insufficient rights”); } res.send(“Welcome, admin!”); }); 🔗 정리: 왜 헷갈렸을까? 구분 정의 Greenwear 당시 실수 인증 사용자가 본인인지 확인 토큰만 발급하고 끝낸 줄 앎 인가 권한 있는지 확인 권한 체크 로직을 누락함 경로 로그인 요청 경로가 맞는지 서버는 /login, 클라는 /api/login AI 빠르지만 검증 필요 기본을 확인하지 않고 자동 완성만 믿음 🌟 마무리하며✅ 인증과 인가는 다르다.✅ 인증은 로그인, 인가는 권한 확인.✅ 로그인 API의 경로와 시큐리티 설정은 반드시 일치시켜야 한다.✅ 토큰에는 role 등 권한 정보를 넣고 백엔드에서 검증하자.✅ AI가 빠르다고 해서 기본 개념을 소홀히 하면 안 된다.Greenwear 프로젝트를 하며 이런 삽질을 경험한 덕분에, 지금은 시큐리티 설정을 할 때 가장 먼저 인증/인가를 분리하고 /login 경로를 명시적으로 permitAll()로 설정해 두는 습관이 생겼습니다.그리고 무엇보다, AI의 도움을 받더라도 내가 이해하고 검증하는 게 중요하다는 걸 배웠습니다. 📖 참고 자료 및 출처https://www.okta.com/ko-kr/identity-101/authentication-vs-authorization/ Authentication vs. Authorization | Okta Products Why Okta Developers Resources Authentication vs. Authorization 업데이트됨: 2024년09월02일 Time to read: ~ Topics IAM 목차 공유 Ready to make Identity a business advantage? Sign up today. Get started What’s the difference between authentication and authorization?  Authentication confirms that users are … www.okta.com https://www.okta.com/ko-kr/identity-101/role-based-access-control-vs-attribute-based-access-control/ RBAC vs. ABAC: Definitions &amp; When to Use | Okta 공유 Identity management techniques protect your sensitive digital assets. But what form should that protection take? Knowing the difference between role-based access control (RBAC) vs. attribute-based access control (ABAC) can help you make a smart decision. The main difference between RBAC vs. ABAC … www.okta.com https://www.youtube.com/watch?v=xCqpxiPXnCk ​ " }, { "title": "[매일매일]백엔드 기술 일기: 회선 교환 vs 패킷 교환 (개념 + 실습 예제)", "url": "/jekyll/update/2025/07/17/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-%ED%9A%8C%EC%84%A0-%EA%B5%90%ED%99%98-vs-%ED%8C%A8%ED%82%B7-%EA%B5%90%ED%99%98-%EA%B0%9C%EB%85%90-%EC%8B%A4%EC%8A%B5-%EC%98%88%EC%A0%9C.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-17 11:27:27 +0900", "content": "개념 정리네트워크에서 회선 교환 방식(Circuit Switching) 이란 특정 사용자를 위한 회선의 경로를 미리 설정하고 이 경로를 이용해서 호스트끼리 메시지를 주고받는 방식을 의미합니다. 회선 교환 방식은 미리 회선을 설정한다는 점에서 주어진 시간 동안에 전송되는 데이터의 양이 비교적 일정하고 안정적입니다. 다만, 회선 이용 효율이 떨어진다는 단점이 존재합니다. 회선 교환 방식의 대표적인 사례로는 유선 전화망이 있습니다.​반면, 패킷 교환 방식(Packet Switching) 은 목적지를 정해두고 메시지를 패킷으로 분할해서 보내고, 목적지에서 패킷을 조립해서 확인하는 방식입니다. 패킷 교환 방식에서 라우터는 주어진 패킷을 최적 경로로 전달하는 핵심적인 역할을 수행합니다. 이러한 특성으로 인해서 경로는 수시로 변경될 수 있고, 데이터를 전송하는 동안에만 네트워크 자원을 사용한다는 점에서 회선 교환 방식과 차이가 있습니다. 패킷 교환 방식은 회선 이용 효율이 높습니다. 하지만, 경로 탐색에서 지연이 발생하거나, 패킷을 위한 헤더로 인한 오버헤드가 발생할 수 있습니다. 출처: https://www.maeil-mail.kr/question/217 구분 회선 교환 (Circuit Switching) 패킷 교환 (Packet Switching) 정의 송신자와 수신자 간에 전용 회선을 설정 후 통신 데이터를 작은 패킷으로 쪼개어 여러 경로로 전송 특징 고정된 경로, 안정적, 비효율적 유연한 경로, 효율적, 지연 가능성 자원 점유 통화 시간 동안 회선 독점 패킷 전송 중에만 네트워크 사용 예시 유선 전화 인터넷, IP 네트워크 회선 교환 예제📋 시나리오1) 전화기 A, B, C가 하나의 교환기에 연결되어 있습니다.2) A가 B에게 전화를 걸면, 교환기가 A-B 전용 회선을 설정하고 통화가 끝날 때까지 점유합니다.3) C가 B에게 전화하려고 하면, 회선이 점유되어 있어 “통화 중” 표시가 됩니다.​실행 화면 예시 📞 Phone A → Dial 1002 📞 Phone B → Ringing… Connected! 📞 Phone C → Dial 1002 📞 Phone C → Line Busy 상태 내용 A ↔ B 연결 전용 회선 설정, 다른 통화 불가 C → B “Line Busy” 표시 패킷 교환 예제📋 시나리오1) PC1, PC2, PC3가 스위치를 통해 라우터에 연결됩니다.2) 동시에 모두 라우터에 ping 명령을 보냅니다.3) 각각의 요청이 독립적인 패킷으로 전송되고 처리됩니다. 🖼️ 실행 화면 예시PC1: Pinging 192.168.1.1 with 32 bytes of data: Reply from 192.168.1.1: bytes=32 time&lt;1ms TTL=64 Reply from 192.168.1.1: bytes=32 time&lt;1ms TTL=64 PC2: Pinging 192.168.1.1 with 32 bytes of data: Reply from 192.168.1.1: bytes=32 time&lt;1ms TTL=64 Reply from 192.168.1.1: bytes=32 time&lt;1ms TTL=64 PC3: Pinging 192.168.1.1 with 32 bytes of data: Reply from 192.168.1.1: bytes=32 time&lt;1ms TTL=64 Reply from 192.168.1.1: bytes=32 time&lt;1ms TTL=64 🔍 왜 셋 다 똑같은가?패킷 교환 방식에서는:각각의 PC가 독립적인 패킷을 전송합니다.패킷들은 동시에 네트워크에 올라가지만 서로 다른 경로나 같은 경로를 차례대로 통과할 수 있습니다.라우터/스위치가 각 패킷을 적절하게 처리하기 때문에 충돌 없이 각각 응답을 받습니다.​동시에 보내더라도 네트워크가 감당할 수 있는 범위 내에서는 모두 응답이 오고, 결과가 동일해 보이는 겁니다. 장단점 요약 방식 장점 단점 회선 교환 일정한 품질, 지연 없음 자원 낭비, 유연성 부족 패킷 교환 자원 효율적, 유연성 높음 패킷 지연, 재조립 필요 📌 포인트✔️ “똑같다” = 잘 작동하고 있다는 증거✔️ 동시에 전송해도 회선 점유가 아니라 패킷 단위 처리라 충돌하지 않음✔️ 각 PC가 전송하는 패킷은 독립적이지만, 응답은 동일한 호스트로부터 동일한 내용 🔷 결론✅ 셋 다 같은 결과가 출력되지만, 그 안에서 패킷은 독립적으로 처리되고 있다는 점이 중요합니다. 참고자료 및 출처https://www.youtube.com/watch?v=FVoPnnC12k8 ⏳ 타임라인 타임스탬프 주제 00:20 범위에 따른 네트워크 분류 01:07 LAN 03:00 WAN 05:02 메시지 교환 방식에 따른 네트워크 분류 06:18 회선 교환 방식 08:12 회선 스위치 10:57 패킷 교환 방식 13:30 패킷 스위치 15:10 패킷 16:05 패킷의 구조 💡 추천:공부하면서 헷갈리는 부분이 있거나 개념이 잘 잡히지 않을 때는, 위 영상을 보면서 용어를 시각적으로 확인해 보세요.특히 회선 교환 방식과 패킷 교환 방식의 차이를 이해할 때 큰 도움이 됩니다. " }, { "title": "[매일매일] 백엔드 기술 일기: Java Try-with-Resources 실습으로 이해하기: finally vs try-with-resources", "url": "/jekyll/update/2025/07/16/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-Java-Try-with-Resources-%EC%8B%A4%EC%8A%B5%EC%9C%BC%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-finally-vs-try-with-resources.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-16 18:54:58 +0900", "content": "실제 코드를 돌려보며 확인하는 예외 처리의 차이점​자바를 사용하다 보면 파일, 데이터베이스 연결, 네트워크 소켓 등의 자원(Resource)을 다루는 일이 많습니다. 이런 자원들은 사용 후 반드시 정리해야 하는데, Java 7부터 도입된 try-with-resources 구문이 이를 획기적으로 개선했습니다.​오늘은 직접 코드를 실습해보며 기존의 finally 방식과 try-with-resources의 차이점을 명확히 알아보겠습니다. 📌 try-with-resources란?try-with-resources는 자바 7부터 도입된 문법으로, 사용한 자원을 자동으로 해제(close)해 주는 try 문입니다.보통 데이터베이스 커넥션, 파일 스트림, 네트워크 소켓처럼반드시 닫아야 하는 자원을 다룰 때 사용합니다. ​🎯 정리하며 느낀 점 finally try-with-resources 코드 길이 길고 중첩됨 짧고 깔끔 예외 출력 따로따로 메인 + suppressed 디버깅 불편 훨씬 쉽다 자원 닫기 직접 호출 자동 finally로는 null 체크하고 try-catch를 또 써야 했는데,try-with-resources는 선언만 하면 알아서 닫아주고, 예외도 한눈에 볼 수 있었습니다.​​🔍예제코드 // Source code is decompiled from a .class file using FernFlower decompiler. public class TryWithResourcesTest { public TryWithResourcesTest() { } public static void main(String[] var0) { System.out.println(“=== finally version ===”); testFinally(); System.out.println(“\\n=== try-with-resources version ===”); testTryWithResources(); } static void testFinally() { CustomResource var0 = null; try { var0 = new CustomResource(); var0.process(); } catch (Exception var10) { System.out.println(\"catch: \" + var10.getMessage()); var10.printStackTrace(); } finally { if (var0 != null) { try { var0.close(); } catch (Exception var9) { System.out.println(\"Exception in finally close(): \" + var9.getMessage()); var9.printStackTrace(); } } } } static void testTryWithResources() { try { CustomResource var0 = new CustomResource(); try { var0.process(); } catch (Throwable var6) { try { var0.close(); } catch (Throwable var5) { var6.addSuppressed(var5); } throw var6; } var0.close(); } catch (Exception var7) { System.out.println(\"catch: \" + var7.getMessage()); var7.printStackTrace(); Throwable[] var1 = var7.getSuppressed(); int var2 = var1.length; for(int var3 = 0; var3 &lt; var2; ++var3) { Throwable var4 = var1[var3]; System.out.println(\"suppressed: \" + var4.getMessage()); var4.printStackTrace(); } } } } ​🔍 Try-with-Resources vs Finally 실습 전체 코드 및 주석 설명 /** 🔍 Try-with-Resources vs Finally 실습 코드 핵심 학습 포인트: ✅ AutoCloseable 인터페이스 필요 ✅ 자원 자동 해제 메커니즘 ✅ 코드 간결성과 안전성 ✅ Suppressed Exception으로 디버깅 향상 */ /** 테스트용 자원 클래스 🔑 핵심: AutoCloseable 인터페이스 구현 필수! try-with-resources 사용하려면 반드시 AutoCloseable 구현해야 함 close() 메서드에서 정리 작업 수행 */ class CustomResource implements AutoCloseable { /** 자원 정리 메서드 (AutoCloseable 인터페이스 구현) 🧪 실습 목적: 의도적으로 예외 발생시켜 차이점 확인 ✔️ 실제 실행해보니 try-with-resources에서는 이 예외가 “Suppressed”로 처리됨! */ @Override public void close() throws Exception { System.out.println(“close() called”); throw new Exception(“Close Exception occurred”); // 의도적 예외 발생 } /** 주요 작업 수행 메서드 🧪 실습 목적: 주 작업 중 예외 발생시켜 예외 처리 방식 비교 ✔️ 실제 실행해보니 이게 “Primary Exception”이 됨 */ void process() throws Exception { System.out.println(“process() called”); throw new Exception(“Primary Exception occurred”); // 의도적 예외 발생 } } public class TryWithResourcesTest { public static void main(String[] args) { System.out.println(“=== finally version ===”); testFinally(); System.out.println(\"\\n=== try-with-resources version ===\"); testTryWithResources(); // 🎯 실행 후 확인사항: // 1. 실행 순서의 차이 // 2. 예외 처리 방식의 차이 // 3. Suppressed Exception 출력 여부 } /** * 🔹 방법 1: 전통적인 finally 방식 * * ❌ 문제점들: * - 코드가 복잡하고 장황함 (중첩된 try-catch) * - null 체크 수동으로 해야 함 * - 예외들이 독립적으로 처리되어 연관성 파악 어려움 * * 📊 실제 실행 결과: * 1. process() called * 2. catch: Primary Exception occurred * 3. [Primary Exception 스택 트레이스] * 4. close() called * 5. Exception in finally close(): Close Exception occurred * 6. [Close Exception 스택 트레이스] ← 별도로 출력됨! */ static void testFinally() { CustomResource resource = null; // null 초기화 필요 try { resource = new CustomResource(); resource.process(); // 여기서 Primary Exception 발생 } catch (Exception e) { // Primary Exception만 캐치됨 System.out.println(\"catch: \" + e.getMessage()); e.printStackTrace(); } finally { // 🔴 수동으로 자원 정리 해야 함 if (resource != null) { // null 체크 필수 try { resource.close(); // 여기서 Close Exception 발생 } catch (Exception e) { // Close Exception이 별도로 처리됨 → 정보 분산! System.out.println(\"Exception in finally close(): \" + e.getMessage()); e.printStackTrace(); } } } // ❌ 결과: 두 예외가 완전히 분리되어 출력됨 // → 디버깅할 때 원인과 결과의 연관성 파악 어려움 } /** * 🔹 방법 2: try-with-resources 방식 (Java 7+) * * ✅ 장점들: * - 코드 간결함 (중첩 제거) * - 자동 자원 관리 (null 체크 불필요) * - Suppressed Exception으로 모든 예외 정보 통합 * - 실행 순서 최적화 (close가 catch보다 먼저) * * 📊 실제 실행 결과: * 1. process() called * 2. close() called ← ⭐ catch 블록보다 먼저 실행됨! * 3. catch: Primary Exception occurred * 4. [Primary Exception 스택 트레이스] * Suppressed: java.lang.Exception: Close Exception occurred ← ⭐ 통합! * 5. suppressed: Close Exception occurred * 6. [Suppressed Exception 스택 트레이스] */ static void testTryWithResources() { // 🟢 리소스를 try 괄호 안에서 선언 → 자동 관리 try (CustomResource resource = new CustomResource()) { resource.process(); // 여기서 Primary Exception 발생 // ⭐ 이 블록을 벗어날 때 자동으로 resource.close() 호출됨! // 심지어 예외가 발생해도 반드시 close() 실행됨 } catch (Exception e) { // Primary Exception 캐치 System.out.println(\"catch: \" + e.getMessage()); e.printStackTrace(); // 여기서 Suppressed Exception도 함께 출력됨! // 🔍 Suppressed Exception 확인 (학습용) for (Throwable suppressed : e.getSuppressed()) { System.out.println(\"suppressed: \" + suppressed.getMessage()); suppressed.printStackTrace(); } } // ✅ 결과: // - Primary Exception이 주 예외로 유지됨 // - Close Exception이 \"Suppressed\"로 첨부됨 // - 하나의 통합된 예외 정보로 완전한 컨텍스트 제공! // → 디버깅할 때 전체 상황을 한눈에 파악 가능 } } /** 🎓 실습 정리 및 핵심 키워드 📌 필수 조건: AutoCloseable 인터페이스 구현 필요 📌 주요 차이점: 실행 순서: finally (process→catch→close) vs try-with-resources (process→close→catch) 예외 처리: finally (분리된 예외) vs try-with-resources (통합된 Suppressed Exception) 코드 복잡도: finally (중첩 구조) vs try-with-resources (간결함) 안전성: finally (수동 관리) vs try-with-resources (자동 관리) 📌 Suppressed Exception의 가치: 원본 예외(Primary) 보존 부가 예외(Close) 정보도 함께 제공 완전한 컨텍스트로 디버깅 효율성 대폭 향상 🚀 결론: try-with-resources는 단순한 문법 설탕이 아닌, 자원 관리와 예외 처리의 패러다임을 바꾼 혁신적 기능! */ 핵심 학습 포인트: ✅ 실제 실행 결과 기반이론이 아닌 실제 콘솔 출력 기반 설명독자가 직접 따라할 수 있는 검증된 코드✅ 시각적 비교표Apply to try-with-res…✅ 실습으로 증명된 인사이트”실제로 돌려보니 정말 다르다!”이론 vs 실제 실행의 차이점 명확히 제시✅ 단계별 학습 가능환경 준비 → 실습 → 결과 분석 → 심화 학습초보자도 따라할 수 있는 친절한 설명✅ 실전 활용까지여러 자원 동시 관리커스텀 자원 클래스 만들기Suppressed Exception 활용​​✔️ finally로 작성했을 때 close() 예외가 덮어써지는 걸 확인✔️ try-with-resources로 돌려보니 suppressed exception이 출력됨 ✔️ AutoCloseable 인터페이스가 꼭 필요함 → 이걸 코드에 주석으로 설명해두자 이거부터 하나하나 차근차근 써보자 예제 코드 실행 결과 ​ " }, { "title": "[매일매일]프론트 엔드 기술 일기: 패키지 매니저 pnpm과 Yarn Berry, 그리고 유령 의존성 문제까지!", "url": "/jekyll/update/2025/07/16/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%ED%94%84%EB%A1%A0%ED%8A%B8-%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%A7%A4%EB%8B%88%EC%A0%80-pnpm%EA%B3%BC-Yarn-Berry-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%9C%A0%EB%A0%B9-%EC%9D%98%EC%A1%B4%EC%84%B1-%EB%AC%B8%EC%A0%9C%EA%B9%8C%EC%A7%80.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-16 14:24:41 +0900", "content": "프론트엔드 개발에서 패키지 매니저는 없어선 안 될 도구입니다.최근에는 전통적인 npm 대신 성능과 효율성을 개선한 pnpm과 Yarn Berry가 주목받고 있는데요.이번 글에서는 두 도구의 특징과 장단점, 그리고 유령 의존성 문제를 해결한 방식까지 함께 살펴보겠습니다. 🚀 pnpm이란?pnpm은 npm 대비 빠르고, 디스크 사용량이 적은 패키지 매니저입니다.🌟 특징과 장점패키지를 설치할 때 매번 복사본을 만들지 않고, 전역 저장소(content-addressable store)에 저장해놓고 하드링크/심볼릭 링크만 프로젝트에 연결합니다.같은 패키지를 여러 프로젝트에서 공유하기 때문에 설치 속도가 빠르고, 디스크 용량도 절약됩니다.유령 의존성 문제가 발생하지 않도록 의존성 트리를 철저히 관리합니다.workspace 기능을 지원해 모노레포 환경에서도 유용하게 사용됩니다. 🎯 Yarn Berry란?Yarn Berry는 Yarn의 2.0 이상 버전을 통칭하며, 기존 Yarn 1.x를 대체하는 버전입니다.특히 PnP(Plug’n’Play)와 Zero Install로 혁신적인 패키지 관리 방식을 도입했습니다.​🌟 특징과 장점node_modules 폴더를 없애고, 대신 .pnp.cjs 파일로 패키지 위치와 의존성을 관리합니다.​패키지들은 .yarn/cache에​ zip 형태로 저장되며 디스크 사용량이 적고, 속도도 빠릅니다.​.yarn/cache와 .pnp.cjs를 함께 Git에 커밋하면 별도의 설치 없이 바로 실행 가능한 Zero Install을 구현할 수 있습니다.​workspace 기능을 지원해 모노레포에 적합합니다.​유령 의존성 문제를 방지합니다. 👻 유령 의존성(Ghost Dependency) 문제란?유령 의존성은 직접 설치하지 않은 패키지를 코드에서 불러올 수 있는 현상입니다.예를 들어, A 패키지가 B를 의존하고 있는데, 내가 A만 설치했더니 B도 설치되어 있고, 코드에서 B를 import해도 동작하는 상황입니다.이는 의존성 트리를 명확히 보장하지 못하기 때문에 발생하며, 다른 환경에서 동일하게 실행되지 않는 문제를 유발할 수 있습니다.🧹 pnpm과 Yarn Berry는 이렇게 해결했습니다pnpm: 각 패키지별로 고립된 환경을 구성해, 실제 의존성에만 접근하도록 강제합니다.Yarn Berry: .pnp.cjs를 통해 의존성의 위치를 정확히 지정해, 정의되지 않은 패키지에는 접근할 수 없도록 합니다. 🤔 단점도 있을까?pnpm익숙하지 않은 개발자들이 많아 도입 시 러닝커브가 존재합니다.일부 레거시 툴(특히 node_modules에 의존하는 도구)과의 호환성이 떨어질 수 있습니다.Yarn Berry역시 기존 Yarn 1.x와 비교했을 때 설정이 까다롭고 학습이 필요합니다..pnp 방식이 모든 도구와 호환되지는 않기 때문에, 환경에 따라 문제를 해결해야 할 수도 있습니다. 📚 참고 자료pnpm 제작 동기https://pnpm.io/ko/next/motivation 동기 | pnpm Saving disk space pnpm.io po4tion.dev: pnpm 파헤치기https://po4tion.dev/pnpm pnpm 파헤치기 pnpm, 난 너가 npm보다 가벼울 줄 알았어… po4tion.dev 토스 기술블로그: node_modules로부터 우리를 구원해 줄 Yarn Berryhttps://toss.tech/article/node-modules-and-yarn-berry node_modules로부터 우리를 구원해 줄 Yarn Berry 토스 프론트엔드 레포지토리 대부분에서 사용하고 있는 패키지 매니저 Yarn Berry. 채택하게 된 배경과 사용하면서 좋았던 점을 공유합니다. toss.tech ✍️ 마무리점점 대규모화되는 프론트엔드 프로젝트에서 패키지 관리의 중요성은 점점 커지고 있습니다.pnpm과 Yarn Berry는 더 빠르고, 더 안전하며, 더 현대적인 패키지 관리를 가능하게 해줍니다.하지만 단점과 특성을 충분히 이해하고 환경에 맞게 선택하는 것이 중요합니다.여러분은 어떤 패키지 매니저를 선호하시나요? 😄 📌 요약✅ pnpm은 전역 저장소를 활용해 빠르고 디스크 효율적인 패키지 관리가 가능하며, 유령 의존성을 방지합니다.✅ Yarn Berry는 PnP와 Zero Install로 node_modules를 없애고, 더 빠르고 안정적인 의존성 관리를 제공합니다.✅ 두 도구 모두 모노레포에 적합하고, 유령 의존성 문제를 해결하지만, 초기 러닝커브와 호환성 이슈는 주의해야 합니다.✅ 환경에 맞는 선택과 충분한 테스트가 중요합니다. " }, { "title": "[매일매일] 백엔드 기술 일기: 모니터링을 위한 핵심 라이브러리, Micrometer 완벽 정리", "url": "/jekyll/update/2025/07/15/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81%EC%9D%84-%EC%9C%84%ED%95%9C-%ED%95%B5%EC%8B%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-Micrometer-%EC%99%84%EB%B2%BD-%EC%A0%95%EB%A6%AC.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-15 14:34:37 +0900", "content": "애플리케이션의 상태를 실시간으로 모니터링하고 싶다면, 그리고 Prometheus나 Datadog, Graphite 등 여러 모니터링 시스템과 연동하고 싶다면?그 답은 바로 Micrometer입니다.오늘은 백엔드 개발에서 점점 더 중요한 위치를 차지하는 Micrometer의 개념, Spring Boot Actuator와의 관계, 그리고 커스텀 메트릭 구현 예제까지 차근차근 살펴보겠습니다. 🔍 Micrometer란?Micrometer는 벤더 중립적인 메트릭 계측 라이브러리입니다.즉, 애플리케이션에서 발생하는 다양한 지표(CPU, 메모리, HTTP 요청 수, 처리 시간 등)를 수집하고, 이를 Prometheus, Datadog, Graphite 같은 모니터링 시스템에 전송할 수 있도록 돕습니다. 📌 핵심은 단순하고 일관된 API(파사드)를 제공해 각 백엔드 클라이언트(Prometheus 클라이언트, Datadog 클라이언트 등)의 복잡한 세부 구현을 감춰준다는 점입니다. Micrometer는 특히 Spring Boot Actuator와 깊게 통합돼 있어, JVM, HTTP, DB 등 기본 메트릭을 자동으로 수집하고 노출해줍니다. ⚙️ Spring Boot Actuator와 MicrometerSpring Boot Actuator는 애플리케이션의 상태, 헬스 체크, 환경, 로그 등 여러 운영 정보를 노출하는 관리 엔드포인트를 제공합니다.하지만 그 내부에서 실제 메트릭을 수집하는 건 Micrometer의 역할입니다. 역할 기능 Actuator 관리 엔드포인트 제공 (/actuator/metrics) Micrometer 메트릭 데이터 수집 및 백엔드 전송 즉, Actuator가 운영자에게 편리한 인터페이스를 제공하고, Micrometer가 그 밑단에서 데이터를 계측하고 있는 구조입니다. 🧪 Micrometer로 커스텀 메트릭 만들기Micrometer를 사용하면 기본 메트릭 외에도, 비즈니스 로직에 맞춘 커스텀 메트릭을 정의할 수 있습니다.다음은 요청 수, 처리 시간, 활성 세션 수를 측정하는 예제입니다.✅ 전체 코드 예제 package com.example.metrics; import io.micrometer.core.instrument.Counter; import io.micrometer.core.instrument.Gauge; import io.micrometer.core.instrument.MeterRegistry; import io.micrometer.core.instrument.Timer; import org.springframework.stereotype.Service; @Service public class CustomMetricsService { private final Counter requestCounter; private final Timer requestTimer; private final CustomGauge customGauge; // 생성자에서 MeterRegistry를 주입받아 필요한 메트릭을 등록합니다. public CustomMetricsService(MeterRegistry meterRegistry) { // HTTP 요청 총 건수를 세는 Counter (태그로 엔드포인트 구분) this.requestCounter = meterRegistry.counter(\"custom.requests.total\", \"endpoint\", \"/api/test\"); // HTTP 요청 처리 시간을 측정하는 Timer (태그로 엔드포인트 구분) this.requestTimer = meterRegistry.timer(\"custom.request.duration\", \"endpoint\", \"/api/test\"); // Gauge: 예를 들어, 현재 활성 세션 수를 측정하기 위한 커스텀 객체를 등록 this.customGauge = new CustomGauge(); Gauge.builder(\"custom.active.sessions\", customGauge, CustomGauge::getActiveSessions) .tag(\"region\", \"us-east\") .register(meterRegistry); } /** * 실제 비즈니스 로직을 실행할 때 요청 카운트와 처리 시간을 측정합니다. * @param requestLogic 실제 처리할 로직 (예: HTTP 요청 처리) */ public void processRequest(Runnable requestLogic) { // 요청 수 증가 requestCounter.increment(); // 요청 처리 시간 측정 requestTimer.record(requestLogic); } /** * 활성 세션 수 업데이트 (예를 들어, 로그인/로그아웃 이벤트에서 호출) * @param activeSessions 현재 활성 세션 수 */ public void updateActiveSessions(int activeSessions) { customGauge.setActiveSessions(activeSessions); } /** * 커스텀 Gauge의 값을 저장하는 내부 클래스. */ private static class CustomGauge { // 현재 활성 세션 수를 저장 (volatile을 사용해 스레드 안정성 확보) private volatile double activeSessions = 0; public double getActiveSessions() { return activeSessions; } public void setActiveSessions(double activeSessions) { this.activeSessions = activeSessions; } } } 🗝️ 주요 구성 요소🏷️ MeterRegistry애플리케이션의 모든 메트릭을 중앙에서 관리합니다.설정된 모니터링 백엔드로 데이터를 주기적으로 전송합니다.🔢 Counter누적 수치(총 요청 수 등)를 측정합니다.예: requestCounter.increment();⏱️ Timer코드 실행 시간(지연 시간)을 측정합니다.예: requestTimer.record(requestLogic);📈 Gauge현재 상태를 실시간으로 반영합니다. (값이 변할 수 있음)예: 현재 활성 세션 수, 현재 대기열 크기 등 🧰 Micrometer를 왜 써야 하나요?✅ 다양한 모니터링 시스템과 연동 가능✅ 단순하고 일관된 API✅ Spring Boot Actuator와의 강력한 통합✅ JVM, OS, DB, HTTP 등 다양한 메트릭 지원✅ 커스텀 메트릭을 통한 비즈니스 데이터 모니터링 가능 📚 추천 자료 및 출[공식 문서] https://micrometer.io/ Micrometer Application Observability Application observability facade for the most popular observability tools. Think SLF4J, but for observability. micrometer.io [Spring Boot Docs] https://docs.spring.io/spring-boot/reference/actuator/index.html Production-ready Features :: Spring Boot Edit this Page GitHub Project Stack Overflow Spring Boot / Reference / Production-ready Features Production-ready Features Spring Boot includes a number of additional features to help you monitor and manage your application when you push it to production. You can choose to manage and monitor your ap… docs.spring.io [Inpa Dev] Spring Boot 모니터링: Micrometer &amp; Prometheushttps://blog.naver.com/71_stars/223684862156 202041206_한화 BEYOND SW캠프 Prometheus/grafana CPU 및 여러 API 모니터링 프로메테우스 1) 설치 apt update apt -y install prometheus prometheus-node-exporter 2) 실행 system… blog.naver.com https://sjh9708.tistory.com/275 [Spring Boot] 시스템 모니터링 : Micrometer + Prometheus + Grafana 서비스가 안정적으로 운영되기 위해서는 애플리케이션의 상태를 수치로 관찰하고, 이상 징후를 빠르게 감지할 수 있어야 한다.특히 MSA나 클라우드 환경처럼 복잡성이 높아질수록 시스템의 가시성(Observability), 즉 관찰 가능한 지표(Metric), 로그(Log), 트레이싱(Trace)를 수집하고 시각화하는 과정이 필요하다. Spring Boot 기반 애플리케이션에서는 주로 Actuator와 Micrometer를 활용해 메트릭을 수집하고, Prometheus를 통해 데이터를 저장, Grafana로 대시보드를 구성하고 시각화하여 … sjh9708.tistory.com 🚀 마무리서버가 느려진다면? 사용자의 요청이 어디서 지체되는지 알고 싶다면?Micrometer를 활용해 애플리케이션의 심장 박동을 모니터링하세요.서비스를 운영하는 개발자라면 반드시 익혀야 할 강력한 도구입니다.궁금한 점이나 추가 예제가 필요하시다면 댓글로 남겨주세요!오늘도 더 좋은 코드를 위해, Happy Coding! 🧡 " }, { "title": "✨ [매일매일] 프론트엔드 기술 일기: 웹 애니메이션 최적화의 핵심, requestAnimationFrame() 완전 정리", "url": "/jekyll/update/2025/07/15/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-%EC%9B%B9-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-%EC%B5%9C%EC%A0%81%ED%99%94%EC%9D%98-%ED%95%B5%EC%8B%AC-requestAnimationFrame-%EC%99%84%EC%A0%84-%EC%A0%95%EB%A6%AC.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-15 14:22:43 +0900", "content": "웹에서 애니메이션을 구현할 때 setTimeout()이나 setInterval()을 사용하곤 합니다. 하지만 이렇게 작성한 애니메이션이 끊기거나 프레임 드롭이 발생한 경험이 있다면, 그 해결책은 바로 requestAnimationFrame()입니다.오늘은 requestAnimationFrame()의 개념부터 장점, 예제까지 알아보고, 왜 프론트엔드 개발자라면 꼭 알아둬야 하는 API인지 정리해보겠습니다. 🖼️ requestAnimationFrame()이란?requestAnimationFrame()은 브라우저의 화면 갱신 주기에 맞춰 콜백 함수를 실행하도록 요청하는 API입니다.즉, 브라우저가 화면을 다시 그리는 최적의 타이밍에 콜백이 호출되므로, 애니메이션이 보다 부드럽고 성능 친화적으로 실행됩니다.브라우저는 일반적으로 초당 60프레임(60fps) 또는 120fps, 144fps 등의 속도로 화면을 갱신합니다. 이 주기에 맞춰 동작하기 때문에, 프레임 드롭 현상을 최소화하고 부드러운 사용자 경험을 제공합니다. 💡 사용 예제예를 들어, 일정 시간 동안 반복되는 애니메이션을 구현한다고 가정해봅시다. const animate = () =&gt; { // 애니메이션에 필요한 동작 수행 console.log(‘애니메이션 프레임 실행!’); if (/* 특정 조건 */) { return; // 조건이 충족되면 종료 } requestAnimationFrame(animate); }; requestAnimationFrame(animate); setTimeout()이나 setInterval()과 달리, requestAnimationFrame()은 브라우저가 렌더링하기 전에 호출되기 때문에 렌더링 주기와 완벽하게 맞아떨어집니다. 🆚 setTimeout()/setInterval()과의 차이점 항목 setTimeout() / setInterval() requestAnimationFrame() 실행 간격 고정 시간 간격 브라우저의 프레임 속도에 맞춤 부드러움 끊김 가능성 매끄러운 애니메이션 배터리/리소스 항상 실행 백그라운드에서 멈춤 주사율 대응 불가능 60Hz, 120Hz 등 자동 대응 🌟 추가적인 장점✅ 디스플레이 주사율에 최적화60Hz, 120Hz, 144Hz 등 모니터 주사율에 맞춰 프레임 속도가 자동 조정됩니다.✅ 백그라운드 탭에서는 실행 중단백그라운드 탭이나 숨겨진 상태에서 애니메이션을 멈춰 배터리 절약과 시스템 자원 최적화에 기여합니다. 🔍 콜백은 어디서 실행될까?requestAnimationFrame()의 콜백은 태스크 큐(Task Queue)나 마이크로태스크 큐(Microtask Queue)가 아닌,브라우저의 렌더링 엔진에 의해 관리됩니다.정확히는 HTML 표준에서는 이를 “map of animation frame callbacks”라 부르며, 별도의 큐에서 독립적으로 관리됩니다.즉, 브라우저 렌더링 사이클과 긴밀히 동작하기 때문에 프레임 드롭 없이 최적의 성능을 낼 수 있습니다. 📚 추천 자료 및 출처[Inpa Dev]https://inpa.tistory.com/entry/%F0%9F%8C%90-requestAnimationFrame-%EA%B0%80%EC%9D%B4%EB%93%9C 🌐 웹 애니메이션 최적화 requestAnimationFrame 가이드 자바스크립트 웹 애니메이션 웹페이지의 애니메이션을 구현할때 CSS의 animatoin , transition , transform 속성을 통해 구현할 수도 있지만, 보다 사용자와의 복잡한 상호작용을 구현하게 하기 위해 Javascript와 함께 사용하여 스타일을 변화시키도 한다. 예를들어 특정 영역을 클릭하거나 웹페이지를 스크롤할때 변화무쌍한 애니메이션 작업들이 그러하다. 그래서 간단하고 규칙적인 애니메이션은 CSS로만 요소의 좌표값이나 스타일 크기를 변화시키고, 세밀한 조작이 필요한 애니메이션은 자바스크립트로 스타일 속성을 변경 … inpa.tistory.com [HTML Standard]https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#list-of-animation-frame-callbacks HTML Standard IDL typedef ( Uint8ClampedArray or Float16Array ) ImageDataArray ; enum ImageDataPixelFormat { “ rgba-unorm8 “ , “ rgba-float16 “ }; dictionary ImageDataSettings { PredefinedColorSpace colorSpace ; ImageDataPixelFormat pixelFormat = “ rgba-unorm8 “; }; [ Exposed =( Window , Worker ), Serializable ]… html.spec.whatwg.org [Stack Overflow]https://stackoverflow.com/questions/77008112/which-queue-is-associated-with-requestanimationframe ✍️ 마무리requestAnimationFrame()은 단순히 애니메이션을 만드는 방법 이상의 의미를 가집니다.사용자의 디바이스 환경에 최적화된 부드러운 경험을 제공하며, 자원 관리 측면에서도 탁월한 선택이죠.앞으로 웹 애니메이션을 구현할 때는 반드시 requestAnimationFrame()을 고려해보세요! 혹시 더 궁금한 부분이나 코드 예제를 확장해보고 싶다면 댓글로 남겨주세요.📧 개발은 성능과 사용자 경험을 함께 고려하는 것! 오늘도 성장하는 하루 되세요. 🌱​ " }, { "title": "✨[매일매일] 프론트엔드 기술 일기: 불변성(Immutability)이란 무엇인가요? — 개념과 이유, 그리고 실전 예제", "url": "/jekyll/update/2025/07/14/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-%EB%B6%88%EB%B3%80%EC%84%B1-Immutability-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%9D%B4%EC%9C%A0-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%8B%A4%EC%A0%84-%EC%98%88%EC%A0%9C.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-14 11:26:55 +0900", "content": "프론트엔드 개발을 하다 보면 상태 관리나 데이터 흐름에서 꼭 듣게 되는 개념이 있습니다. 바로 불변성(Immutability)입니다.이번 글에서는 불변성이 무엇인지, 왜 지켜야 하는지, 그리고 어떻게 지킬 수 있는지 쉽게 정리해 보겠습니다. 📖 불변성이란? 불변성(Immutable)이란 데이터가 한 번 생성된 이후에는 그 상태를 변경할 수 없는 성질을 말합니다. 프로그래밍 언어에서 문자열, 숫자처럼 기본 데이터 타입은 불변(immutable)입니다. 예를 들어, 문자열에 새로운 글자를 더하면 실제로는 기존 문자열을 수정하지 않고 새로운 문자열을 만들어 반환합니다.하지만 객체와 배열처럼 참조 타입은 기본적으로 가변(mutable)입니다. 즉, 생성된 객체의 프로퍼티를 언제든지 바꿀 수 있습니다. const person = { name: “Alice”, age: 25 }; // ❌ 불변성을 깨는 예제 person.age = 26; 위처럼 기존 객체를 직접 수정하면 코드의 예측 가능성이 떨어지고, 디버깅이 어려워질 수 있습니다. 🧾 불변성을 지키려면?불변성을 유지하기 위해서는 기존 데이터를 수정하지 않고, 새로운 데이터(객체나 배열)를 생성해야 합니다.✅ 스프레드 연산자 const updatedPerson = { …person, age: 26 }; ✅ Object.assign() const updatedPerson = Object.assign({}, person, { age: 26 }); ✅ Object.freeze()객체를 동결하여 더 이상 수정할 수 없게 만듭니다. const frozenPerson = Object.freeze(person); frozenPerson.age = 30; // 무시됨 ✅ Immutable.js, Immer.js라이브러리를 사용해 더 직관적이고 안전하게 불변성을 지킬 수도 있습니다. 🤔 불변성은 왜 중요한가요? 불변성은 코드의 예측 가능성과 안정성을 높입니다. 🌱 장점데이터의 변경 흐름을 쉽게 추적할 수 있다.디버깅과 상태 관리가 쉬워진다.리액트(React)와 같은 라이브러리에서 shouldComponentUpdate, useMemo, PureComponent 등의 최적화 기법과 잘 맞아 떨어진다.과거 상태를 유지하거나 롤백하기 쉬워진다.​⚠️ 단점매번 새로운 객체를 생성하기 때문에 메모리 사용량이 약간 늘어날 수 있다.하지만 성능에 미치는 영향은 대부분의 경우 무시할 수 있는 수준입니다. 📚 추천 학습 자료✅ [10분 테코톡] 소피아의 데이터타입과 불변성 — 유튜브https://www.youtube.com/watch?v=hM8s3ZaycGk ✅ [evan-moon] 변하지 않는 상태를 유지하는 방법, 불변성(Immutable) — 블로그https://evan-moon.github.io/2020/01/05/what-is-immutable/ 변하지 않는 상태를 유지하는 방법, 불변성(Immutable) 이번 포스팅에서는 순수 함수에 이어 함수형 프로그래밍에서 중요하게 여기는 개념인 에 대한 이야기를 해보려고 한다. 사실 순수 함수를 설명하다보면 불변성에 대한 이야기가 꼭 한번은 나오게 되는데, 대부분 “상태를 변경하지 않는 것”이라는 짧은 정의로 설명하거나, 혹은 불변성을 해치는 행위들을 예시로 들고 이런 행위들을 금지 행위로 규정하며 설명을 진행하게된다. 그러나 개인적으로 이런 설명 방식은 상태와 메모리에 대한 개념이 확실하게 정립되지 않은 사람에게 별로 와닿지 않는 방식일 수도 있다고 생각한다. 그래서 이번 포스팅에서는 정확… evan-moon.github.io 🔗 마무리프론트엔드 개발에서는 상태 관리가 중요하고, 상태 관리에서 불변성을 지키는 것이 핵심입니다. 불변성은 코드의 버그를 줄이고 유지보수성을 높이는 좋은 습관이니, 작은 프로젝트에서부터 의식적으로 연습해 보세요.혹시 더 깊이 있는 라이브러리 예제(Immutable.js/Immer.js)나 리액트 상태 관리 사례까지 추가로 보고 싶다면 말씀해 주세요! 🚀 🙋‍♀️ “데이터는 직접 수정하지 말고, 항상 새로 만들어라!”이 한 문장만 기억해도 불변성의 절반은 이해한 것입니다. 🎯 " }, { "title": "[매일매일] 백엔드 기술 일기: 시간 복잡도와 공간 복잡도의 차이, 그리고 빅오(Big-O) 표기법 완전 정리", "url": "/jekyll/update/2025/07/14/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84%EC%99%80-%EA%B3%B5%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84%EC%9D%98-%EC%B0%A8%EC%9D%B4-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%B9%85%EC%98%A4-Big-O-%ED%91%9C%EA%B8%B0%EB%B2%95-%EC%99%84%EC%A0%84-%EC%A0%95%EB%A6%AC.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-14 11:19:10 +0900", "content": "알고리즘을 선택하거나 성능을 분석할 때 가장 많이 듣는 말이 바로 시간 복잡도와 공간 복잡도입니다. 또한 이를 표현하는 방법으로는 흔히 빅오(Big-O) 표기법을 사용합니다. 이번 글에서는 이 세 가지 개념을 쉽게 이해할 수 있도록 정리했습니다. 출처 및 참고https://velog.io/@welloff_jj/Complexity-and-Big-O-notation 복잡도(Complexity): 시간 복잡도와 공간 복잡도, 그리고 빅오(Big-O) 표기법 시간 복잡도와 공간 복잡도, 그리고 빅오 표기법 velog.io 🕒 시간 복잡도(Time Complexity)시간 복잡도란? 알고리즘이 실행될 때, 입력 크기 nnn에 따라 연산을 몇 번 수행하는지를 수치화한 것. 예를 들어, 배열의 모든 요소를 한 번씩 순회해야 하는 경우라면 입력 크기에 비례하여 연산이 늘어나므로 O(n)이라고 표현합니다.왜 필요한가요?실행 시간을 실제로 재면, 기계 성능이나 현재 상태에 따라 다르게 나옵니다. 그래서 더 일반화된 기준으로 연산량을 계산해 속도를 비교하는 것이 좋습니다.예를 들어, 두 알고리즘이 둘 다 1초 이내에 끝난다고 해도, 입력이 커질수록 성능 차이가 크게 벌어질 수 있기 때문에 시간 복잡도를 분석합니다. 💾 공간 복잡도(Space Complexity)공간 복잡도란? 알고리즘이 실행될 때 필요한 메모리 사용량을 입력 크기 nnn에 따라 표현한 것. 예를 들어, 입력 배열 외에 새로운 배열을 하나 더 만들어야 하는 알고리즘이라면 메모리가 추가로 필요하고, 이 메모리 사용량이 얼마나 늘어나는지 표현합니다.즉, 시간은 빠르지만 메모리를 많이 쓰는지, 메모리를 적게 쓰지만 느린지 등 트레이드오프를 고려할 수 있습니다. 🔍 빅오(Big-O) 표기법시간과 공간 복잡도를 표현할 때 가장 널리 쓰이는 것이 바로 빅오 표기법입니다. 입력 크기 nnn이 커질수록 알고리즘의 실행 시간 또는 메모리 사용량이 어떻게 변하는지를 나타내는 점근적 표기법입니다. ✨ 특징계수는 무시: 5n5n5n, 100n100n100n처럼 상수배는 무시합니다. → O(n)가장 큰 항만 남김: n2+n+1n^2 + n + 1n2+n+1이라면 → O(n²) 📑 빅오 표기법 예시 코드 빅오 for (int i = 0; i &lt; n; i++) O(n) for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) O(n²) for (int i = 0; i &lt; n; i++)for (int i = 0; i &lt; m; i++) O(n + m) for (int i = 0; i &lt; n * k; i++) O(n) (상수 k는 무시) // n이 입력되면 n번 루프가 반복되므로, O(n)으로 표기합니다. for (int i = 0; i &lt; n; i++) { … } // 아래 루프는 O(n)으로 표기합니다. n이 무한에 가까울 수록 k가 의미가 없기 때문입니다. (상수항과 계수 무시) int k = 5; for (int i = 0; i &lt; n * k; i++) { … } // 입력값인 n과 m이 독립적이라면 빅오는 더할 수 있습니다. O(n + m)으로 표기합니다. for (int i = 0; i &lt; n; i++) { … } for (int i = 0; i &lt; m; i++) { … } // 빅오는 곱해질 수 있습니다. O(n^2)으로 표기합니다. for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n * 5; j++) {} } // 가장 큰 항 외에는 무시할 수 있습니다. O(n^2)로 표기합니다. for (int i = 0; i &lt; n; i++) {} for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) {} } 🧰 추천 학습 자료✅ [10분 테코톡] 🙋‍♂️ 제이의 시간복잡도 — 유튜브https://www.youtube.com/watch?v=IEH3YA2Nn4Q ✅ Eleanor Lim님 유튜브 — 빅오(Big-O) 표기법 완전정복https://www.youtube.com/watch?v=6Iq5iMCVsXA ✅ 노마드 코더 — 개발자라면 이제는 알아야 하는 Big-O 설명해드림 (10분컷)https://www.youtube.com/watch?v=BEVnxbxBqi8 🔗 마무리시간 복잡도와 공간 복잡도는 알고리즘을 평가하는 두 가지 축입니다. 둘 다 적절히 고려하여 효율적인 코드를 작성하는 것이 중요합니다. 그리고 이를 표현하는 빅오 표기법은 개발자라면 꼭 알아야 할 기본기이니, 위 자료를 참고해 복습해보시길 추천합니다. 🙌 ​ " }, { "title": "‍♂️ 52패밀리 으쌰으쌰 러닝 크루 | 매주 금요일 잠원 한강에서 함께 달리기", "url": "/jekyll/update/2025/07/12/52%ED%8C%A8%EB%B0%80%EB%A6%AC-%EC%9C%BC%EC%8C%B0%EC%9C%BC%EC%8C%B0-%EB%9F%AC%EB%8B%9D-%ED%81%AC%EB%A3%A8-%EB%A7%A4%EC%A3%BC-%EA%B8%88%EC%9A%94%EC%9D%BC-%EC%9E%A0%EC%9B%90-%ED%95%9C%EA%B0%95%EC%97%90%EC%84%9C-%ED%95%A8%EA%BB%98-%EB%8B%AC%EB%A6%AC%EA%B8%B0.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-12 12:34:18 +0900", "content": "안녕하세요, 오늘은 제가 매주 금요일마다 함께하는 러닝 크루 활동을 소개하려고 합니다.5월부터 지금까지 꾸준히 금요일 저녁마다 모여 잠원 한강공원에서 5~8km씩 달리고 있어요.이름하여 “52패밀리 으쌰으쌰 러닝 크루”! 🌙 한강의 밤, 그리고 우리퇴근 후 저녁, 잠원 한강공원에 모여 스트레칭을 하고 러닝을 시작합니다.한강의 야경과 시원한 바람을 맞으며 달리는 그 기분은 정말 최고예요.처음에는 다들 각자 속도에 맞춰 달리다가도, 결국은 함께 모여 웃고 즐기는 게 우리 크루의 매력입니다. 🏃‍♂️ 나를 이겨내는 시간어제는 새로 산 런닝복과 런닝화를 신고 처음으로 달렸어요.제가 평발이라서 달리다 보면 발에 물집이 잡힐 정도로 아플 때도 있었는데, 새로 산 런닝화가 가볍고 착용감도 좋아서 훨씬 뛰기 편하더라고요.사실 매주 금요일마다 뛰면서 힘들어서 포기하고 싶을 때도 많아요.하지만 그럴 때마다 “조금만 더 가자”, “저기 선까지만 가자”, “저기 꼬깔까지만 가자” 이렇게 마음속으로 다짐하면서 달려요.평소에는 잡생각이 많고 마음이 산만한데, 이렇게 달릴 때만큼은 오직 한 걸음 한 걸음에 집중하면서 나를 이겨내는 기분이 들어요.체력도 조금씩 좋아지고 있다는 게 느껴져서 더 뿌듯합니다. 📈 오늘의 기록매주 이렇게 기록을 남기면서 서로의 성취를 공유하고 응원합니다.🩷 걸음 수: 9,406 / 목표 6,000🩷 활동 시간: 94분 / 목표 90분🩷 활동 칼로리: 500 / 목표 500 오늘의 러닝 기록은 아래와 같습니다:거리: 5.02 km시간: 28분 08초평균 페이스: 5’35”/km평균 심박수: 155 bpm소모 칼로리: 363 kcal경로는 이렇게 한강변을 따라 쭉 달렸어요. 📸 함께라서 더 즐거운 러닝마지막은 늘 이렇게 단체 사진으로 마무리!서로를 응원하고, 함께 웃고, 함께 땀 흘리는 이 시간이 참 소중합니다. ✨ 앞으로도 으쌰으쌰!매주 금요일, 잠원 한강공원에서 52패밀리 크루는 계속 달립니다.혹시 한강에서 함께 뛰고 싶은 분이 있다면 언제든 함께해요.“혼자 뛰는 것보다, 함께 뛰면 더 멀리 갈 수 있다”는 걸 매번 느낍니다.여러분도 이번 주말, 가벼운 러닝 어떠세요? 🏃‍♀️🏃‍♂️ " }, { "title": "[매일매일]백엔드 기술 일기: CDN, 백엔드 개발자가 알아야 할 핵심 지식", "url": "/jekyll/update/2025/07/11/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-CDN-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%ED%95%B5%EC%8B%AC-%EC%A7%80%EC%8B%9D.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-11 11:59:33 +0900", "content": "안녕하세요! 오늘은 백엔드 개발자라면 반드시 알아야 할 CDN(Content Delivery Network) 의 개념과 동작 원리, 그리고 사용 시 주의할 점까지 정리했습니다.CDN은 백엔드 서버의 부담을 줄이고, 전 세계 사용자에게 빠르고 안정적으로 콘텐츠를 제공하는 중요한 기술입니다. 🌐 CDN이란?CDN(Content Delivery Network) 은 전 세계에 분산된 서버 네트워크를 통해, 사용자에게 물리적으로 가장 가까운 서버에서 콘텐츠를 전달하는 시스템입니다.백엔드 서버의 부하를 분산하고, 통신 지연(latency)을 최소화하여 성능을 개선합니다.백엔드 입장에서 보면, 원본 서버(origin)의 역할을 최소화하고, 정적 콘텐츠(HTML, CSS, JS, 이미지 등)를 CDN이 대신 서비스함으로써 효율적으로 트래픽을 처리할 수 있습니다. 📌 대표적인 CDN 서비스AWS CloudFrontCloudflareAkamaiFastly ⚙️ CDN의 동작 원리CDN은 클라이언트 요청을 받으면, 요청한 콘텐츠를 자신의 캐시에 가지고 있으면 바로 응답하고, 없으면 원본 서버에서 받아와 캐싱 후 응답합니다.즉, 백엔드 서버를 거치지 않거나 최소한 한 번만 거치도록 해서 불필요한 부하를 줄입니다. 🔷 Push 방식과 Pull 방식​✅ Push 방식백엔드 서버가 콘텐츠를 미리 CDN으로 전송항상 최신 콘텐츠를 빠르게 서비스 가능관리 주체가 백엔드 서버이므로 콘텐츠 업데이트를 지속적으로 수행해야 함관리 비용이 상대적으로 높음 📌 백엔드가 “미리 보내놓고 준비”하는 방식 ✅ Pull 방식클라이언트가 요청한 콘텐츠가 CDN에 없으면, CDN이 원본 서버에서 가져와 캐싱 후 응답초기 요청 시에는 백엔드 서버가 직접 응답하지만 이후부터는 CDN이 처리관리가 더 쉽고, 자주 요청되는 콘텐츠만 캐싱됨 📌 백엔드가 “필요할 때만 제공”하는 방식 📝 CDN 사용 시 고려할 점백엔드 개발자는 CDN을 도입할 때 아래 요소들을 신중히 검토해야 합니다.​1️⃣ 비용CDN 서비스는 대부분 유료입니다.모든 트래픽을 무조건 CDN으로 처리하지 않고, 정적 콘텐츠 위주로 전략적으로 사용해 비용을 최적화해야 합니다.​2️⃣ 캐싱 만료 시간만료 시간이 너무 길면 오래된 콘텐츠가 노출되고, 너무 짧으면 원본 서버 요청이 빈번해집니다.적절한 TTL(Time-To-Live) 설정이 필요합니다.​3️⃣ 장애 대응CDN에 장애가 발생했을 때, 클라이언트가 원본 서버로 직접 요청하도록 백업 플랜을 마련해야 합니다.​4️⃣ 콘텐츠 무효화업데이트된 콘텐츠를 빠르게 반영해야 할 때는 버저닝이나 CDN 무효화 API를 활용합니다. 📚 더 알아보기https://www.youtube.com/watch?v=_kcoeK0ITkQ https://www.youtube.com/watch?v=Zz-IehTBgjY https://www.youtube.com/watch?v=54PLQS4OS5E https://cottonblue.tistory.com/31 글로벌 비디오 서비스가 가능하게 한 넷플릭스의 Microservice 아키텍쳐 구조 분석 Cao Duc Nguyen 원문 링크 A Design Analysis of Cloud-based Microservices Architecture at Netflix | by Cao Duc Nguyen | The Startup | Medium 역주 그림을 따라서 보아야하는 단어들의 경우는 굳이 한국어로 바꾸지 않고 그림과 똑같은 단어를 사용하였습니다. 1. 시작 넷플릭스는 매년 전세계 인터넷 트래픽의 15% 이상([ 12 ])을 차지하고 있습니다. 2019년에는 이미 1억 6700만명의 구독자가 생겼고, 매 4분기 마다 5백만명이 2… cottonblue.tistory.com https://www.youtube.com/watch?v=Grhua7yhWh4 ✍️ 마무리CDN은 오늘날 백엔드 시스템의 필수 요소 중 하나입니다.서버 비용과 부하를 줄이면서도 빠르고 안정적인 서비스를 제공하기 위해 반드시 이해하고 활용해야 할 기술입니다.서비스의 성격과 요구 사항에 맞게, Push와 Pull 방식을 선택하고, TTL과 장애 대응을 적절히 설계해 보세요. 📌 TIP: 백엔드와 프론트엔드가 함께 캐싱 전략을 논의하면 더욱 효율적인 시스템을 설계할 수 있습니다. ​ " }, { "title": "[매일매일]프론트 엔드 기술 일기: Content-Type 헤더 완전 이해하기", "url": "/jekyll/update/2025/07/11/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%ED%94%84%EB%A1%A0%ED%8A%B8-%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-Content-Type-%ED%97%A4%EB%8D%94-%EC%99%84%EC%A0%84-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-11 11:52:12 +0900", "content": "안녕하세요! 오늘은 HTTP 통신에서 빠질 수 없는 핵심 헤더 중 하나인 Content-Type 에 대해 정리합니다.API 요청을 만들 때, 혹은 서버 응답을 처리할 때 꼭 알아둬야 할 개념이니 차근차근 읽어주세요. 🌱 사진 출처: https://velog.io/@vekkary/Content-type%EC%9D%B4%EB%9E%80 🌟 Content-Type이란?Content-Type 은 HTTP 요청(request)과 응답(response)에서 전송되는 데이터의 타입을 명시하는 헤더입니다.서버와 클라이언트가 데이터를 주고받을 때, 올바르게 해석할 수 있도록 알려주는 역할을 합니다. 📌 데이터의 형식을 명확히 지정하지 않으면, 서버/클라이언트가 데이터를 잘못 처리하거나 오류가 발생할 수 있습니다. ✨ Content-Type의 형식Content-Type은 MIME 타입 기반으로 작성됩니다.형식은 다음과 같습니다. [type]/[subtype] 예시 데이터 형식 Content-Type 값 JSON application/json HTML 문서 text/html 평문 텍스트 text/plain 파일 업로드(Form) multipart/form-data URL 인코딩된 폼 데이터 application/x-www-form-urlencoded 🖋️ 요청/응답에서의 역할요청(Request)클라이언트가 서버에 데이터를 보낼 때, 데이터의 형식을 명시합니다.예: JSON 데이터 전송 POST /api/login HTTP/1.1 Content-Type: application/json { “username”: “kks”, “password”: “1234” } 응답(Response)서버가 클라이언트에 데이터를 보낼 때도 Content-Type을 지정해, 브라우저가 올바르게 렌더링할 수 있게 합니다.예: HTML 페이지 응답 HTTP/1.1 200 OK Content-Type: text/html 🚨 Content-Type을 잘못 지정하면?만약 전송한 데이터와 Content-Type이 일치하지 않으면 서버나 클라이언트가 데이터를 잘못 해석하거나, 오류 코드(예: 415 Unsupported Media Type)를 반환할 수 있습니다. 예: JSON 데이터인데 application/x-www-form-urlencoded로 설정 → 파싱 실패 가능성. 🤔 Content-Type vs AcceptContent-Type과 혼동하기 쉬운 헤더가 하나 있죠! 바로 Accept 헤더입니다. 헤더 이름 의미 Content-Type 클라이언트가 보내는 데이터의 형식 Accept 클라이언트가 받고자 하는 데이터의 형식 예: 클라이언트가 서버에 JSON을 전송하고, 서버로부터 JSON 응답을 받고 싶을 때 POST /api HTTP/1.1 Content-Type: application/json Accept: application/json 📚 더 읽어보기🔗 [MDN] https://developer.mozilla.org/ko/docs/Web/HTTP/Reference/Headers/Content-Type Content-Type - HTTP | MDN Content-Type 개체 헤더는 리소스의 media type을 나타내기 위해 사용됩니다. developer.mozilla.org 🔗 [rookieand 벨로그]https://velog.io/@rookieand/MIME-type%EC%9D%80-%EB%AD%90%EA%B3%A0-Content-type%EC%9D%80-%EB%AD%94%EB%8D%B0 MIME type은 뭐고, Content-type은 뭔데? 내가 아는 MIME 이라고는 인터넷에서 나도는 그 밈밖에 몰랐는데… velog.io 📝 마무리프론트엔드 개발을 하면서 API 요청/응답을 디버깅하다 보면, Content-Type이 빠져 있거나 잘못 지정돼서 문제가 생기는 경우가 많습니다.내가 보내는 데이터의 형식이 무엇인지, 그리고 서버가 원하는 형식이 무엇인지 항상 확인하세요!오늘도 작은 배움이 쌓이는 하루 되시길 바랍니다. 🙌​ " }, { "title": "[매일매일]백엔드 기술 일기: 스프링 트랜잭션 전파 속성, 한 번에 정리하기", "url": "/jekyll/update/2025/07/10/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-%EC%8A%A4%ED%94%84%EB%A7%81-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%86%8D%EC%84%B1-%ED%95%9C-%EB%B2%88%EC%97%90-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-10 14:20:28 +0900", "content": "안녕하세요! 오늘은 스프링의 트랜잭션 전파 속성(Transaction Propagation) 에 대해 정리해 보았습니다.스프링에서 @Transactional 어노테이션을 사용할 때, 이미 트랜잭션이 진행 중이라면 어떻게 동작할지 결정하는 중요한 속성입니다.단순히 @Transactional만 붙이는 것에서 한 발 더 나아가, 서비스 설계에 맞게 올바르게 설정하는 것이 중요합니다. 🔷 트랜잭션 전파란?스프링에서는 하나의 비즈니스 로직이 여러 메서드로 나눠져 있을 때, 각 메서드마다 트랜잭션을 따로 시작할지, 아니면 기존 트랜잭션에 참여할지를 정할 수 있습니다.예를 들어 A 메서드에서 트랜잭션이 이미 시작된 상태에서 B 메서드를 호출할 때, B 메서드가 어떻게 동작할지 결정하는 것이 바로 전파 속성입니다.@Transactional(propagation = Propagation.XXX) 형태로 설정할 수 있습니다. ✅ 주요 전파 속성1️⃣ REQUIRED (기본값)이미 트랜잭션이 존재하면 해당 트랜잭션을 사용합니다.트랜잭션이 없으면 새로운 트랜잭션을 생성합니다.가장 많이 쓰이는 기본값입니다. 예: “이미 진행 중이면 거기서 같이 처리하고, 없으면 내가 시작할게!” 2️⃣ REQUIRES_NEW항상 새로운 트랜잭션을 생성합니다.기존 트랜잭션이 있다면 잠시 보류(Suspend) 합니다.독립적으로 처리해야 할 작업에 유용하지만, 남용하면 성능/예외 처리에 문제가 될 수 있습니다. 예: “내 건 내가 알아서 할게, 기존 작업은 잠깐 멈춰.” 3️⃣ MANDATORY반드시 트랜잭션이 있어야만 실행됩니다.트랜잭션이 없으면 예외를 발생시킵니다. 예: “트랜잭션 없으면 못해!” 4️⃣ SUPPORTS트랜잭션이 있으면 그 안에서 실행하고, 없으면 트랜잭션 없이 실행합니다. 예: “있으면 쓰고, 없어도 괜찮아.” 5️⃣ NOT_SUPPORTED트랜잭션이 있으면 일시 중단하고, 트랜잭션 없이 실행합니다.트랜잭션이 없는 상태에서만 처리해야 하는 작업에 사용됩니다. 예: “트랜잭션 중에는 못해, 잠깐 멈추고 진행해.” 6️⃣ NESTED이미 트랜잭션이 있으면 Savepoint를 찍고 중첩 트랜잭션을 시작합니다.외부 트랜잭션이 롤백되면 중첩 트랜잭션도 함께 롤백됩니다. 예: “혹시 몰라서 중간 저장해둘게.” 7️⃣ NEVER트랜잭션이 존재하면 예외를 발생시키고, 없으면 트랜잭션 없이 실행합니다. 예: “트랜잭션 있으면 안 돼!” 🚨 주의사항: REQUIRES_NEWREQUIRES_NEW 는 독립적인 트랜잭션이 필요할 때 매우 유용하지만, 남용하면 위험합니다.너무 많이 사용하면 데이터베이스에 부하가 큽니다.트랜잭션 경계가 복잡해지고, 예외 처리가 어려워질 수 있습니다.가능하면 꼭 필요한 상황에서만 사용하는 것을 권장합니다. 📚 더 읽어보기https://www.youtube.com/watch?v=b0s9RzKyHN0 https://www.youtube.com/watch?v=cc4M-GS9DoY https://mangkyu.tistory.com/269 [Spring] 스프링의 트랜잭션 전파 속성(Transaction propagation) 완벽하게 이해하기 아래의 내용은 김영한님의 디비 접근 기술 2편 강의와 토비의 스프링 등을 바탕으로 정리한 내용입니다.    1. 트랜잭션의 시작과 종료 및 전파 속성(Transaction Propagation)[ 트랜잭션의 시작과 종료 ]트랜잭션은 시작 지점과 끝나는 지점이 존재한다. 시작하는 방법은 1가지이지만 끝나는 방법은 2가지이다. 트랜잭션이 끝나는 방법에는 모든 작업을 확정짓는 커밋(commit)과 모든 작업을 무효화하는 롤백(rollback)이 있다.  트랜잭션의 시작트랜잭션은 하나의 Connection을 가져와 사용하다가 닫는 사이에서… mangkyu.tistory.com https://stackoverflow.com/questions/37927208/nested-transaction-in-spring-app-with-jpa-postgres​https://hstory0208.tistory.com/entry/REQUIRESNEW%EC%97%90-%EB%8C%80%ED%95%9C-%EC%98%A4%ED%95%B4%EC%99%80-%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90 REQUIRES_NEW에 대한 오해와 주의할 점 REQUIRES_NEW에 대한 오해REQUIRES_NEW를 사용하면 물리적으로 트랜잭션이 분리되어 분리한 트랜잭션의 예외가이 트랜잭션을 호출한 상위 트랜잭션에 전파되지 않는다고 이해하고 있었다. 결론부터 말하면 아니였다.어떤식으로 트랜잭션 흐름이 진행되는지 한번 알아보자.@Service@RequiredArgsConstructorpublic class MeetingService { private final MeetingRepository meetingRepository; private final MemberService memberS… hstory0208.tistory.com ✍️ 마무리스프링의 전파 속성은 강력한 도구지만, 잘못 사용하면 서비스에 혼란을 줄 수 있습니다.비즈니스 로직과 트랜잭션 경계를 정확히 정의하고, 필요한 속성을 신중히 선택하는 습관을 가지세요.혹시 더 궁금한 내용이나 사례가 있다면 댓글로 남겨주세요! 🙌​ " }, { "title": "[매일매일] 프론트엔드 개발 일기: JWT(Json Web Token)의 장점과 단점: 왜, 언제 써야 할까?", "url": "/jekyll/update/2025/07/10/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C-%EC%9D%BC%EA%B8%B0-JWT-Json-Web-Token-%EC%9D%98-%EC%9E%A5%EC%A0%90%EA%B3%BC-%EB%8B%A8%EC%A0%90-%EC%99%9C-%EC%96%B8%EC%A0%9C-%EC%8D%A8%EC%95%BC-%ED%95%A0%EA%B9%8C.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-10 14:07:14 +0900", "content": "안녕하세요! 오늘은 프론트엔드 개발자라면 꼭 알아야 할 JWT(Json Web Token) 의 장점과 단점에 대해 정리해보았습니다. 최근 웹 서비스에서 인증/인가를 구현할 때 많이 사용하는 방식인 만큼, 개념과 특성을 잘 이해해 두면 좋습니다. 🔷 JWT란?JWT(Json Web Token) 는 JSON 포맷으로 사용자 정보를 안전하게 전달하기 위해 사용하는 토큰입니다.주로 사용자 인증(Authentication)과 권한 부여(Authorization)를 위해 사용되며, Stateless한 인증 방식이라는 점이 가장 큰 특징입니다. ✅ JWT의 장점​1️⃣ 서버 상태를 저장하지 않는 Stateless 인증JWT는 서버가 세션을 저장하지 않고도 인증을 처리할 수 있습니다.서버의 메모리나 데이터베이스에 사용자 상태를 유지할 필요가 없기 때문에, 서버 확장(Scale-out)이 쉽고 리소스 부담이 적습니다. 💡 왜 좋을까?서버가 여러 대로 분산되어도 토큰만 유효하다면 어디서든 인증이 가능합니다. 2️⃣ 토큰에 정보를 담아 DB 조회 없이 인증 가능JWT는 사용자 ID, 권한(Role) 등 필요한 정보를 토큰 안에 담아 발급합니다.따라서 클라이언트가 요청할 때마다 DB를 조회하지 않고도 사용자 정보를 확인할 수 있어 속도가 빠르고 부하가 적습니다. 3️⃣ 데이터 무결성 보장JWT는 서명(Signature)을 포함하기 때문에, 클라이언트가 토큰의 내용을 임의로 수정해도 서버에서 쉽게 검증할 수 있습니다.즉, 토큰이 위조되지 않았는지 검증할 수 있어 보안에 유리합니다. ⚠️ JWT의 단점​1️⃣ 로그아웃을 강제하기 어렵다JWT는 Stateless한 구조라서, 서버가 클라이언트가 가진 토큰을 “취소”할 수 없습니다.토큰은 발급 시 정한 유효기간이 끝나야 만료되며, 그 이전에는 여전히 유효합니다.따라서 세션 기반 인증처럼 즉시 로그아웃시키거나 토큰을 무효화하기 어렵습니다. 2️⃣ 토큰 크기와 네트워크 부하JWT는 단순한 세션 ID보다 크기가 큽니다.사용자 정보와 서명이 포함되기 때문에, 요청/응답마다 네트워크에 추가적인 부담이 생길 수 있습니다. 📚 참고 자료 및 출처https://www.youtube.com/watch?v=1QiOXWEbqYQ https://yceffort.kr/2021/05/drawback-of-jwt JWT의 단점과 주의사항 https://yceffort.kr yceffort.kr https://velog.io/@mygomi/TIL-50-JWT%EC%97%90-%EB%8C%80%ED%95%B4-%EB%B0%9C%ED%91%9C%ED%95%B4%EB%B3%B4%EA%B2%A0%EC%8A%B5%EB%8B%88%EB%8B%A4 TIL 50 | JWT 원리와 장단점 매우 빠른 템포로 개발을 배우고 있는 상황에서 주위 환경에 끌려가지 않고 지식을 최대한 흡수하기 위해서는 어떻게 해야 할까? 내가 내린 결론은 새로운 개념을 아는 것에 급급하기 보다 내가 구현해 본 기능을 온전히 이해하고 설명할 수 있는지에 집중해야 한다는 것이다. velog.io ✍️ 마무리JWT는 서버 확장성과 편리한 인증 처리를 가능하게 해주지만, 무조건적인 만능 열쇠는 아닙니다.서비스의 특성과 보안 수준에 맞춰, 세션 기반 인증과 JWT의 장단점을 비교해 선택하는 것이 중요합니다. 📌 TIP: 로그아웃/무효화 문제를 해결하기 위해 블랙리스트, 짧은 만료 + 리프레시 토큰 같은 패턴을 함께 사용하는 것이 좋습니다. ​ " }, { "title": "[GreenWear 개발일지] 백엔드 API 개발 & 통합 작업 회고록 (2025.07.09)", "url": "/jekyll/update/2025/07/09/GreenWear-%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80-%EB%B0%B1%EC%97%94%EB%93%9C-API-%EA%B0%9C%EB%B0%9C-%ED%86%B5%ED%95%A9-%EC%9E%91%EC%97%85-%ED%9A%8C%EA%B3%A0%EB%A1%9D-2025-07-09.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-09 22:12:54 +0900", "content": "안녕하세요, 김기성입니다.오늘은 제가 개발 중인 친환경 패션 전자상거래 플랫폼 GreenWear의 백엔드 API 개발과 통합 작업 과정을 기록해둡니다.어찌저찌 스프링 부트 서버까지 띄워두긴 했지만, 그 과정에서 경로 문제와 각종 오류에 막히며 고생했던 하루였네요. ​ｇｉｔ주소： https://github.com/saway126/greaenwear GitHub - saway126/greaenwear Contribute to saway126/greaenwear development by creating an account on GitHub. github.com 📌 프로젝트 소개GreenWear는 친환경 의류를 판매하는 전자상거래 플랫폼입니다.환경 점수, 재활용 함량, 인증 여부 등을 제품 데이터에 담아 지속 가능한 패션의 가치를 전하고자 기획했습니다. “지속 가능한 패션의 미래를 기술로 만들어간다.” 💻 Frontend: Vue.js 3🖋️ Backend: Spring Boot 3.5.3🗄️ Database: H2 (개발 단계) ✍️ 오늘의 작업 로그１。 백엔드 아키텍처 구축JWT 기반 인증과 Spring Security를 적용해 보안과 인증 체계를 잡았습니다.RESTful API로 회원가입, 로그인, 제품 CRUD, 헬스체크까지 엔드포인트를 설계하고 구현했습니다.​２。 데이터 모델링친환경 제품의 특성을 표현할 수 있도록 엔티티 설계를 진행했습니다. ecoRating, recycledContent, organicCertified, fairTradeCertified 등 환경 관련 필드를 추가 ３。 프론트엔드 연동Axios 서비스 계층에 JWT 인터셉터를 붙여 Vue 컴포넌트와 백엔드 API를 연결했습니다.로그인, 회원가입, 제품 목록 API까지 프론트와 연동 완료. 🔧 해결한 문제들Spring Boot 3.x 마이그레이션 이슈 deprecated된 .cors().and() 문법 → .cors(cors -&gt; cors.configurationSource(…))로 변경 JWT 필터 오류 @NonNull 어노테이션 누락으로 컴파일 에러 → 빠르게 수정 Windows PowerShell 명령어 오류 Linux 스타일 명령어(q, &amp;&amp;)를 써서 실행 불가 → PowerShell에 맞는 명령으로 대체 🧨 힘들었던 점이번 작업에서 제일 답답했던 건 커서가 파일 경로나 빌드 경로를 제대로 못 찾는 문제였습니다.Spring Boot 서버는 실행됐지만, 빌드 과정에서 디렉토리 구조를 못 찾거나 null 오류가 터지는 상황이 반복됐습니다.오류 메시지를 검색하고 디렉토리 상태를 하나하나 점검하면서 결국은 원인을 찾았지만, “AI를 쓰면 더 빨라질 줄 알았는데, 오히려 경로를 못 잡아 답답할 때가 있구나”라는 걸 크게 느꼈던 순간이었습니다. 앞으로는 디렉토리 구조와 파일 경로를 명확히 이해하고, 커서를 “학습”시키는 방법(예: .vscode/settings.json 수정, 터미널 경로 지정)을 따로 연습해야겠다고 다짐했습니다. 🌟 주요 성과✅ Spring Boot 백엔드 API 시스템 구축✅ JWT 인증 체계 적용✅ 프론트(Vue)와 API 연동✅ H2 DB 초기 데이터 설정✅ README 최신화 및 문서화✅ GitHub backend-api-development 브랜치에 푸시 완료 git push -u origin backend-api-development Pull Request 생성:https://github.com/saway126/greaenwear/pull/new/backend-api-development 📊 현재 상태 요약백엔드: 90% 완료 (API 구현 &amp; 테스트 필요)프론트엔드: 80% 완료 (API 연동 코드 완성)데이터베이스: 100% 완료 (H2 DB 구성 &amp; 데이터 세팅)문서화: 100% 완료 (개발일지, README 최신화) 💡 클로드 AI와의 협업 경험이번 백엔드의 초안은 클로드 AI가 작성한 코드로 시작했습니다.빠르게 구조를 잡고 진행할 수 있었지만, 역시 AI가 작성한 코드라서 제가 직접 로직을 이해하고 수정해가며 학습하는 과정이 필요했습니다.AI를 잘 활용하면 생산성이 올라가지만, 결국 이해와 유지보수는 사람의 몫이라는 것을 다시 한번 느꼈습니다. 🌱 배운 점과 회고👍 잘한 점보안을 고려한 JWT 인증 시스템 구축친환경 데이터 모델링을 고민한 점디버깅 과정에서 하나씩 검증하며 차근차근 진행한 점​🥲 아쉬운 점초기 환경 설정에 생각보다 시간을 너무 많이 소모경로 문제와 빌드 과정에 대한 이해 부족커서와의 연계 및 학습이 미흡AI가 작성한 코드를 그대로 가져다 쓰기보다는, 이해하고 내 것으로 만드는 연습이 필요하다는 점​🔷 개선 방안디렉토리와 경로 구조를 명확히 파악해 커서를 효과적으로 학습시키기.vscode 설정 파일과 빌드 스크립트를 표준화Swagger 도입으로 API 문서화 강화Docker 환경 구성으로 빌드 및 실행 일관성 확보 “지속 가능한 패션의 미래를 만들어가는 여정에서, 기술적 도전은 더 나은 개발자로 성장하게 한다.” 오늘 하루도 성장했습니다.읽어주셔서 감사합니다. 🏷️ 해시태그#GreenWear #개발일지 #회고록 #SpringBoot #VueJS #JWT #H2Database #백엔드개발 #커서학습 #클로드AI #AI코드활용 #지속가능한패션 #김기성개발자 ​ " }, { "title": "[매일매일] 백엔드 기술 일기: 동시성 문제, 경쟁 상태를 해결하기 위해 보장해야 할 것들", "url": "/jekyll/update/2025/07/09/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C-%EA%B2%BD%EC%9F%81-%EC%83%81%ED%83%9C%EB%A5%BC-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%B4-%EB%B3%B4%EC%9E%A5%ED%95%B4%EC%95%BC-%ED%95%A0-%EA%B2%83%EB%93%A4.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-09 13:25:08 +0900", "content": "멀티스레드 환경에서 자주 발생하는 문제 중 하나가 바로 경쟁 상태(Race Condition) 입니다.여러 스레드가 동시에 같은 자원에 접근해 작업하면서 실행 순서에 따라 예상치 못한 결과가 발생하는 현상이죠.그렇다면 경쟁 상태를 방지하려면 어떤 조건을 만족해야 할까요?오늘은 핵심 개념인 원자성(Atomicity) 과 가시성(Visibility) 에 대해 살펴보고, Java에서 이를 보장하는 방법을 소개합니다. 🕹️ 경쟁 상태란?경쟁 상태는 여러 스레드가 동시에 공유 자원에 접근하고, 그 실행 순서에 따라 결과가 달라지는 상황입니다.예를 들어 i++ 연산을 두 스레드가 동시에 실행하면 예상보다 적은 값으로 결과가 남는 문제를 경험할 수 있습니다. 🔍 해결을 위한 두 가지 핵심: 원자성과 가시성1️⃣ 원자성 (Atomicity)원자성은 작업이 더 이상 나눌 수 없는 하나의 단위로 실행되는 성질입니다.i++처럼 하나의 문장으로 보이는 연산도 실제로는 다음 세 단계로 나뉩니다:1. i의 현재 값을 읽음 (Read) 2. 1을 더함 (Modify) 3. 결과를 다시 i에 씀 (Write) 만약 두 스레드가 이 과정 중에 서로 개입하면 다음과 같은 일이 벌어집니다: Thread 1 Thread 2 i 읽기 (10) i 읽기 (10) i+1 (11) i+1 (11) i에 11 쓰기 i에 11 쓰기 결과적으로 i는 두 번 증가했어야 하지만 실제로는 한 번만 증가합니다. ➡️ 원자성이 깨졌기 때문입니다. 2️⃣ 가시성 (Visibility)가시성은 한 스레드가 변경한 값을 다른 스레드가 즉시 볼 수 있는 성질입니다.현대 CPU는 각 코어마다 캐시가 있어서, 변경된 값이 메인 메모리에 바로 반영되지 않고 캐시에 머무를 수 있습니다.이 때문에 다른 스레드는 메모리에 반영되지 않은 이전 값을 계속 읽게 됩니다.➡️ 즉시 최신 상태가 보장되지 않기 때문에 문제가 됩니다. ☕ Java에서 보장하는 방법Java에서는 다양한 방법으로 원자성과 가시성을 보장할 수 있습니다. 방법 보장하는 성질 설명 synchronized 원자성 + 가시성 블록이나 메서드 단위로 임계 구역 설정 ReentrantLock 원자성 + 가시성 명시적으로 락을 걸고 해제 AtomicInteger 등 원자성 + 가시성 CAS(Compare-And-Swap) 기반 연산 volatile 가시성만 CPU 캐시 대신 메모리에서 직접 읽음 주의!volatile은 가시성만 보장합니다. 하나의 스레드가 쓰고, 다른 스레드가 읽는 경우에만 적합합니다. (읽기-수정-쓰기 연산에는 부적합) ✨ 요약✅ 경쟁 상태를 방지하려면 원자성과 가시성이 모두 필요하다.✅ 원자성: 작업이 더 이상 나눠지지 않고 실행✅ 가시성: 변경된 값이 다른 스레드에서 바로 보임✅ Java에서는 synchronized, lock, Atomic 클래스, volatile 등을 활용 📚 추가 학습 자료https://www.youtube.com/watch?v=ktWcieiNzKs https://www.youtube.com/watch?v=sQ-G8Gd5qVU ​ " }, { "title": "[매일매일]프론트 엔드 기술 일기: CSS 의사 요소(Pseudo-elements)와 의사 클래스(Pseudo-classes) 완전 정리", "url": "/jekyll/update/2025/07/09/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%ED%94%84%EB%A1%A0%ED%8A%B8-%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-CSS-%EC%9D%98%EC%82%AC-%EC%9A%94%EC%86%8C-Pseudo-elements-%EC%99%80-%EC%9D%98%EC%82%AC-%ED%81%B4%EB%9E%98%EC%8A%A4-Pseudo-classes-%EC%99%84%EC%A0%84-%EC%A0%95%EB%A6%AC.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-09 13:15:07 +0900", "content": "프론트엔드 개발을 하다 보면 CSS 선택자만으로는 부족할 때가 있습니다.예를 들어, 특정 요소의 일부만 스타일링하거나, 특정 상태일 때만 스타일을 바꾸고 싶다면?이럴 때 유용하게 쓸 수 있는 것이 바로 의사 요소와 의사 클래스입니다.오늘은 두 개념의 차이와 활용법을 예시 코드와 함께 정리해보겠습니다. 🧩 의사 요소란?의사 요소(Pseudo-elements)는 HTML 요소의 특정 부분을 선택해 스타일을 적용하는 기능입니다.HTML을 수정하지 않고도 요소의 앞, 뒤, 첫 글자, 첫 줄 등에 스타일을 지정할 수 있어 편리합니다.대표적인 의사 요소 의사 요소 설명 ::before 요소의 시작 부분에 콘텐츠 삽입 ::after 요소의 끝 부분에 콘텐츠 삽입 ::first-letter 요소의 첫 글자 선택 ::first-line 요소의 첫 줄 선택 예제: 버튼 앞에 아이콘 추가하기 button::before { content: ‘🔥’; margin-right: 5px; } 위 코드를 적용하면 버튼의 텍스트 앞에 불꽃 이모지가 나타납니다. 🧩 의사 클래스란?의사 클래스(Pseudo-classes)는 HTML 요소의 특정 상태나 조건을 선택하는 기능입니다.예를 들어, 마우스가 올라갔을 때(:hover), 첫 번째 요소일 때(:first-child) 등에만 스타일을 다르게 지정할 수 있습니다.대표적인 의사 클래스 의사 클래스 설명 :hover 마우스를 올렸을 때 :active 클릭했을 때 :focus 포커스가 갔을 때 :first-child 부모 안에서 첫 번째 자식 :last-child 부모 안에서 마지막 자식 예제: 버튼에 마우스 오버 시 스타일 변경 button:hover { background-color: #ffcccc; } 📊 의사 요소 vs 의사 클래스 구분 기준 예시 의사 요소 요소의 특정 부분 선택 ::before, ::after 의사 클래스 요소의 특정 상태/조건 선택 :hover, :focus 쉽게 말해:의사 요소: 어디의 부분인지의사 클래스: 어떤 상태인지 ✨ 요약✅ 의사 요소는 요소 내부의 특정 부분에 스타일 적용✅ 의사 클래스는 요소의 상태나 조건에 따라 스타일 적용✅ ::before / ::after를 활용해 불필요한 HTML을 만들지 않아도 된다.✅ 두 개념을 잘 조합하면 더 유연하고 깔끔한 CSS 코드를 작성할 수 있다. 📚 참고 자료https://www.tcpschool.com/css/css_selector_pseudoElement 코딩교육 티씨피스쿨 4차산업혁명, 코딩교육, 소프트웨어교육, 코딩기초, SW코딩, 기초코딩부터 자바 파이썬 등 www.tcpschool.com https://www.tcpschool.com/css/css_selector_pseudoClass 코딩교육 티씨피스쿨 4차산업혁명, 코딩교육, 소프트웨어교육, 코딩기초, SW코딩, 기초코딩부터 자바 파이썬 등 www.tcpschool.com ​ " }, { "title": "GreenWear 개발 회고록: AI와 함께한 나의 첫 스마트웨어 프로젝트(Vue,Java Spring Boot, MariaDB)", "url": "/jekyll/update/2025/07/08/GreenWear-%EA%B0%9C%EB%B0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D-AI%EC%99%80-%ED%95%A8%EA%BB%98%ED%95%9C-%EB%82%98%EC%9D%98-%EC%B2%AB-%EC%8A%A4%EB%A7%88%ED%8A%B8%EC%9B%A8%EC%96%B4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-Vue-Java-Spring-Boot-MariaDB.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-08 13:58:41 +0900", "content": "​🌱 GreenWear 개발 회고록: AI와 함께한 나의 첫 스마트웨어 프로젝트📌 GitHub: saway126/greaenwear Previous image Next image 🗓️ 시작: 2024년 5월 21일, 부트캠프를 마치고지난 5월 21일, 한화 BEYOND SW 부트캠프를 마치고 집으로 돌아온 날, 문득 이런 생각이 들었습니다.”이제 혼자서도 뭔가를 만들어 보고 싶다.”하지만 막상 노트북을 켜고 IDE를 띄우자, 코드가 아닌 ‘두려움’이 먼저 떠오르더군요.​지금 내 실력으로 완성도 높은 무언가를 만들 수 있을까?무턱대고 시작하면 몇 주 만에 지치진 않을까?그렇게 고민하다가, 요즘 관심 있던 스마트 헬스케어를 주제로 간단히 프로젝트를 시작해보기로 했습니다.​이 프로젝트의 이름은 GreenWear.”색상으로 생명을 구한다”라는 슬로건을 붙인, 스마트웨어 아이디어의 첫 걸음이었습니다. 🚀 AI를 곁에 둔 개발예전이라면 이런 프로젝트를 처음부터 끝까지 혼자 코딩했겠지만, 요즘은 시대가 달라졌습니다.이번에는 처음부터 AI를 적극적으로 개발 파트너로 삼아보기로 했습니다.​🤖 내가 사용한 도구들Cursor AI코드를 거의 직접 작성하지 않아도 됐습니다.요구사항을 입력하면 커밋 단위로 새로운 파일과 폴더를 만들어주고, 내 폴더 구조에 맞춰서 맥락 있는 코드를 제안해줬습니다.필요한 부분만 살짝 고치거나, 내 스타일에 맞게 커스터마이즈하면 됐습니다.https://www.youtube.com/watch?v=_oEhh8666pA Claude CLI긴 코드 리뷰나 컨셉 정리, README 개선 등에 큰 도움이 됐습니다.“이 아키텍처에 필요한 구성 요소를 한 문단으로 요약해줘” 같은 요청에 아주 유용했습니다.https://www.youtube.com/watch?v=b76trMwxRwg Google CLICLI 상에서 구글 검색을 바로 하며 빠르게 레퍼런스를 찾을 수 있어 생산성이 좋았습니다.https://www.youtube.com/watch?v=f-Izv0ZIeQs Figma to Cursor MCPFigma에서 디자인을 만들고 그대로 Cursor에서 코드화하는 실험도 해봤습니다.https://www.youtube.com/watch?v=ONqfqSiS7JM&amp;t=497s 🪴 프로젝트를 진행하며혼자 작업하면서 커서를 켜놓고 명령을 입력하면, 뼈대가 거의 자동으로 만들어지고, 화면 구성도 빠르게 잡히는 걸 보며 정말 놀랐습니다.”내가 직접 작성하는 건 아니지만, 내가 원하는 방향으로 코드를 다듬고 커스터마이즈할 수 있다”이게 진짜 개발자가 해야 할 일이라는 걸 느꼈습니다.이번 프로젝트에서 제가 직접 작성한 코드는 거의 없습니다.대신 시스템의 구조를 정의하고, 어떤 데이터를 보여줄지 설계하고, UI의 스타일을 조정하며 제 색깔을 입혔습니다. 💡 개발자로서의 생각이번 프로젝트를 하며 가장 크게 느낀 건, AI가 선택이 아니라 필수인 시대가 왔다는 것이었습니다.예전엔 ‘코딩을 잘해야 좋은 개발자’라고 생각했지만,지금은 ‘AI를 잘 활용하고, 설계와 디렉션을 잘 잡을 줄 아는 사람’이 더 좋은 개발자라는 걸 깨달았습니다.​📝 내가 할 일:시스템과 UI를 설계하는 방향 설정AI가 작성한 코드를 읽고 이해하며 수정/검수프로젝트 전체의 브랜딩과 사용자 경험 설계​🖋️ AI가 도와준 일:코드 작성폴더 구조 자동화boilerplate 생성README 작성 및 문서화 📊 앞으로의 계획이번에 만든 건 어디까지나 뼈대입니다.여기서 더 발전시켜 다음 목표를 세워두었습니다.📌 백엔드 구축 (Node.js + MongoDB)📌 WebSocket으로 실시간 데이터 통신📌 Arduino/RaspberryPi로 센서 연동📌 모바일 앱으로 확장 🙋🏻‍♂️ 회고이 프로젝트는 아직 완성된 제품이 아니지만, 나에게는 의미 있는 첫 발걸음입니다.혼자 공부하며 아이디어를 기획하고, AI와 함께 빠르게 프로토타입을 만들어가는 과정 자체가 성장의 경험이었습니다.AI가 발전하는 시대에 개발자로서 내가 할 일은 줄어드는 게 아니라, 더 가치 있는 일로 집중할 수 있도록 만드는 것임을 깨달았습니다. 📝 마무리앞으로도 이런 개인 프로젝트를 통해 내 생각을 실현하는 방법을 배우고, AI와 함께 더 효율적으로 성장하는 개발자가 되고 싶습니다.“색상으로 생명을 구한다”는 이 슬로건처럼, 사람들에게 도움이 되는 제품을 만들 수 있도록 계속 배우고 시도하겠습니다. 📌 GitHub: https://github.com/saway126/greaenwear🏷️ 태그:#개발일지 #Vue.js #AI개발 #CursorAI #스마트헬스케어 #프론트엔드 #개발회고​ " }, { "title": "[매일매일] 백엔드 기술일기: DNS란 무엇인가요? 그리고 어떻게 작동할까요?", "url": "/jekyll/update/2025/07/08/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0%EC%9D%BC%EA%B8%B0-DNS%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%91%EB%8F%99%ED%95%A0%EA%B9%8C%EC%9A%94.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-08 12:44:10 +0900", "content": "안녕하세요! 오늘은 네트워크 개발자라면 꼭 알아야 할 핵심 개념,DNS(Domain Name System) 에 대해 알아보겠습니다. 🧩 DNS란?우리는 인터넷을 사용할 때 www.google.com 같은 도메인 주소를 입력합니다.하지만 실제로 컴퓨터들은 IP 주소(예: 142.250.206.4)를 이용해 통신합니다.IP는 사람이 기억하기 어렵기 때문에, 도메인을 IP로 바꿔주는 전화번호부 같은 시스템이 필요합니다.그게 바로 DNS입니다. 📖 DNS (Domain Name System)도메인 이름과 IP 주소를 서로 매핑하고 관리하기 위한 시스템 혹은 이를 구현하는 프로토콜 🔍 DNS의 역할✅ 사람이 읽을 수 있는 도메인 → 컴퓨터가 이해하는 IP로 변환✅ 전 세계 어디서든 일관된 네임스페이스 제공✅ 네임 서버를 계층적으로 관리해 분산 처리 가능 🧭 DNS 질의 과정api.maeil-mail.kr의 IP 주소를 찾는 과정을 예시로 들어 설명하겠습니다.📝 주요 등장인물로컬 네임 서버 (Local Name Server)사용자의 PC/ISP가 기본으로 설정해둔 DNS 서버 (예: 구글 DNS 8.8.8.8)​루트 네임 서버 (Root Name Server)전 세계에 13개 존재하며, 최상위 도메인(.com, .kr 등)을 관리하는 서버의 주소를 알려줌​TLD 네임 서버 (Top-level Domain Server).com, .kr 등 특정 최상위 도메인 영역을 관리​권한 네임 서버 (Authoritative Name Server)특정 도메인의 최종 정보를 가지고 있는 서버 (예: maeil-mail.kr 소유자가 운영) 🔗 전체 흐름1️⃣ 클라이언트 → 로컬 네임 서버 브라우저가 먼저 로컬 네임 서버에 api.maeil-mail.kr의 IP를 묻습니다.(여기서 캐시에 있다면 바로 반환) 2️⃣ 로컬 네임 서버 → 루트 네임 서버 로컬 네임 서버는 루트 네임 서버에 질문합니다.루트 서버는 .kr TLD 네임 서버의 주소를 알려줍니다. 3️⃣ 로컬 네임 서버 → TLD 네임 서버 이번엔 .kr TLD 네임 서버에 질문합니다.TLD 서버는 maeil-mail.kr 권한 네임 서버의 주소를 알려줍니다. 4️⃣ 로컬 네임 서버 → 권한 네임 서버 마지막으로 권한 네임 서버에 api.maeil-mail.kr의 IP를 요청하고 응답을 받습니다. 5️⃣ 로컬 네임 서버 → 클라이언트 최종적으로 클라이언트에게 IP를 전달하고, 로컬 서버는 이 정보를 캐싱합니다. 📝 정리DNS는 도메인 이름과 IP 주소를 매핑하는 시스템입니다.계층적으로 설계되어 분산 처리 및 안정성을 확보합니다.로컬 → 루트 → TLD → 권한 서버를 거쳐 IP를 찾습니다. 📚 추가 학습 자료 및 출처https://www.youtube.com/watch?v=sDXcLyrn6gU https://www.youtube.com/watch?v=X2hcteH8kR0 https://www.youtube.com/watch?v=XXzxetbAIfA https://docs.tosspayments.com/resources/glossary/dns DNS(Domain Name System) | 토스페이먼츠 개발자센터 DNS(Domain Name System)는 웹사이트의 도메인 주소를 IP 주소로 변환하는 시스템입니다. docs.tosspayments.com https://okms1017.tistory.com/97 지리적 라우팅 설계 ✍ Posted by Immersive Builder  Seong 지리적 라우팅지리적 라우팅(geo-routing)이란 사용자의 지리적 위치에 따라 가장 가까운 데이터 센터로 트래픽을 전달하는 라우팅 방식을 말합니다. GeoDNS는 사용자의 IP 주소를 기반으로 위치를 추정하여 가장 가까운 서버의 IP 주소로 도메인을 변환하는 작업을 수행합니다. 지리적 라우팅을 제공하는 서비스로는 AWS Route 53, Cloudflare Load Balancing, Akamai Edge DNS 등이 있습니다.  동작 원리아래 아키텍처는 지리적 … okms1017.tistory.com 🚀 인터넷이 돌아가기 위해서는 수많은 DNS 서버들이 쉼 없이 작동하고 있습니다.DNS는 단순한 이름-주소 변환 이상의 역할을 하며, 네트워크 인프라의 핵심입니다! 이 내용을 마크다운 파일이나 카드 뉴스 형태로도 만들어 드릴 수 있습니다.필요하시다면 말씀해 주세요. 🙌 " }, { "title": "Vue의 setup()과 React 함수형 컴포넌트 비교", "url": "/jekyll/update/2025/07/08/Vue%EC%9D%98-setup-%EA%B3%BC-React-%ED%95%A8%EC%88%98%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%B9%84%EA%B5%90.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-08 12:33:12 +0900", "content": "Vue의 setup()과 React 함수형 컴포넌트는 모두 함수 기반 선언형 UI를 구현하기 위한 핵심입니다.하지만 두 프레임워크가 상태와 렌더링을 관리하는 방식이 다르기 때문에, 이 둘에도 미묘한 차이가 있습니다. ✨ 공통점✅ 함수처럼 실행된다.둘 다 컴포넌트를 렌더링할 때마다 함수처럼 호출됩니다.✅ 상태 선언과 로직 작성이 한 곳에 모인다.둘 다 컴포넌트의 로직(데이터, 이벤트, 라이프사이클 등)을 한 함수 안에서 작성합니다.✅ 선언형 UI를 지향한다.상태가 변하면 UI를 자동으로 다시 렌더링합니다. 🚧 차이점 항목 Vue setup() React 함수형 컴포넌트 상태 관리 방식 ref() / reactive()로 반응형 객체를 만든다. useState()로 상태를 정의하고 setState()로 갱신 상태 위치 Vue 인스턴스에 속한다. (reactive system) 렌더링마다 순서대로 관리되는 상태 슬롯 호출 순서 규칙 순서가 달라져도 괜찮다. (Vue가 상태 객체를 기억) 호출 순서가 꼭 같아야 한다. (useState() 순서 중요) 라이프사이클 onMounted, onUnmounted 등 setup() 안에서 직접 사용 useEffect() 안에 의존성 배열과 함께 작성 템플릿 연결 return한 객체의 속성들이 템플릿과 자동 연결됨 JSX로 상태와 렌더링을 직접 매핑 📝 정리Vue와 React는 둘 다 현대적인 선언형 UI 개발을 지향하지만,Vue는 내부의 reactivity system이 상태를 관리하기 때문에 ref를 언제 어디서 선언해도 안전합니다.반면 React는 Hook의 순서에 의존하므로 최상단에서 항상 동일한 순서로 호출해야 합니다. 📌 Tip Vue를 오래 써온 개발자라면 React에서도 상태 선언을 무심코 조건문에 넣기 쉽습니다.리액트에서는 반드시 모든 useState, useEffect가 컴포넌트 최상단에 선언되도록 주의하세요! " }, { "title": "[매일매일] 프론트엔드 기술 일기: 왜 useState를 조건문 안에서 사용하면 안 되나요?(Vue 개발자 시점에서)", "url": "/jekyll/update/2025/07/08/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-%EC%99%9C-useState%EB%A5%BC-%EC%A1%B0%EA%B1%B4%EB%AC%B8-%EC%95%88%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%95%88-%EB%90%98%EB%82%98%EC%9A%94-Vue-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%8B%9C%EC%A0%90%EC%97%90%EC%84%9C.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-08 12:30:56 +0900", "content": "안녕하세요! 오늘은 리액트에서 자주 하는 실수 중 하나인useState를 조건문 안에서 호출하는 문제에 대해 정리해 보겠습니다.저는 평소에 Vue를 주로 사용해 왔는데, 리액트를 배우면서 이 부분이 낯설게 느껴졌습니다.Vue와 리액트는 상태를 관리하는 방식에 큰 차이가 있기 때문인데요.Vue를 많이 써본 분들이라면, 이 차이를 이해하면 더 쉽게 리액트에 적응할 수 있습니다. 🧩 리액트 Hook의 규칙리액트 공식 문서에서는 Hook을 사용할 때 두 가지 중요한 규칙을 강조합니다.✅ 항상 컴포넌트의 최상위 레벨에서 호출할 것✅ 항상 동일한 순서로 호출할 것이 규칙이 깨지면 리액트가 상태를 올바르게 관리하지 못하고,예기치 못한 버그가 발생할 수 있습니다. 🧩 Vue와 React의 상태 관리 방식 차이✅ VueVue는 data() 객체 안에서 reactive 상태를 선언합니다.이 상태는 컴포넌트 인스턴스에 속하고, 언제 렌더링을 하든 어디서 접근하든 항상 존재합니다. 상태를 조건문 안에서 “변경”하는 것은 괜찮습니다.상태를 만드는(ref) 건 컴포넌트가 생성될 때 항상 한 번만 실행됩니다. ✅ React리액트는 useState()를 호출하는 순서를 기반으로 상태를 추적합니다. const [count, setCount] = useState(0) 이렇게 최상단에서 순서대로 useState()가 호출되어야, 리액트가 첫 번째 상태 = count로 인식합니다. ⚠️ 문제 상황다음과 같은 코드를 보겠습니다. function Example({ shouldUseState }) { if (shouldUseState) { const [count, setCount] = useState(0); } return &lt;div&gt;Example Component&lt;/div&gt;; } 이 코드에서는 shouldUseState가 true일 때만 useState가 호출됩니다.그런데 렌더링 도중 shouldUseState가 false로 바뀌면, useState가 더 이상 호출되지 않게 되죠. 🧪 리액트 내부 동작리액트는 컴포넌트를 렌더링할 때, Hook을 호출한 순서대로 상태를 기록합니다.즉, 첫 번째 useState는 count, 두 번째 useState는 name… 이런 식으로 순서를 기억합니다.하지만 조건문에 의해 어떤 렌더링에서는 useState가 호출되고,다른 렌더링에서는 호출되지 않는다면,리액트가 상태를 매칭할 때 순서가 꼬이게 됩니다.그 결과, 엉뚱한 값이 들어가거나 렌더링 에러가 발생합니다. 🧭 올바른 코드 예시조건을 걸어야 한다면, 상태 자체는 항상 정의해 두고렌더링이나 로직에서 조건을 분기해야 합니다. function Example({ shouldUseState }) { const [count, setCount] = useState(0); return ( &lt;div&gt; Example Component {shouldUseState &amp;&amp; &lt;p&gt;Count: {count}&lt;/p&gt;} &lt;/div&gt; ); } 이렇게 하면 useState는 항상 동일한 순서로 호출되고,렌더링만 조건에 따라 다르게 됩니다. 📝 정리Vue는 ref()로 만든 상태가 컴포넌트 인스턴스에 고정되어 있어 어디서 접근하든 안전하다.React는 useState()를 호출하는 순서에 의존하므로, 조건문/반복문 안에 두면 안 된다.상태 선언은 항상 컴포넌트 함수 최상단에서! 📚 추가 학습 자료React 공식 문서 - Hook 규칙d5br5.dev - React useState 동작 원리 이해하기 🚀 Vue에 익숙하다 보면 리액트의 Hook 규칙이 처음엔 낯설 수 있습니다.하지만 이 규칙만 기억해도 안정적이고 예측 가능한 코드를 작성할 수 있습니다! ​ " }, { "title": "[매일매일]프론트 엔드 기술 일기: Vue & Node.js 프로젝트에서 효과적으로 디버깅하는 방법", "url": "/jekyll/update/2025/07/07/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%ED%94%84%EB%A1%A0%ED%8A%B8-%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-Vue-Node-js-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%94%94%EB%B2%84%EA%B9%85%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-07 11:32:46 +0900", "content": "프론트엔드(Vue)와 백엔드(Node.js) 개발을 하면서 디버깅은 매일같이 마주하게 되는 중요한 작업입니다.“디버깅을 잘한다”는 것은 단순히 버그를 고치는 게 아니라, 문제를 빠르게 이해하고 효과적으로 해결해가는 과정이라고 생각합니다.오늘은 Vue &amp; Node.js 기반 프로젝트에서 경험한 실제 사례와 함께, 제가 사용하는 디버깅 노하우를 정리해 봅니다. 🪧 디버깅 단계 요약 단계 내용 1️⃣ 오류 메시지 꼼꼼히 읽기 2️⃣ 문제를 작은 단위로 격리 3️⃣ 정상 흐름과 문제 흐름 비교 4️⃣ 공식 문서 및 검증된 자료 활용 5️⃣ 디버깅 도구 적극 활용 6️⃣ 과정 기록하기 🔷 실제 프로젝트 오류 사례다음은 제가 실제 프로젝트를 진행하면서 Vue와 Node.js API 연동 중 발생한 에러입니다. 에러 메시지를 보면 다음과 같습니다:GET /api/product/company/undefined 400 (Bad Request)GET /api/product/detail/3 500 (Internal Server Error)Vue Router: No match found for location with path “/productRegist”​✅ 이 사례에서 알 수 있는 문제점:백엔드 API 호출 시 undefined가 파라미터로 전달됨 → 프론트 데이터 바인딩 문제특정 ID에 대한 요청에서 500 오류 → 백엔드 서버 로직 문제잘못된 경로로 라우팅 시도 → Vue Router 설정 문제 🧐 1. 오류 메시지를 꼼꼼히 읽기에러 메시지를 끝까지 읽고, 어디서 무엇 때문에 발생했는지를 정확히 파악합니다.위 사례처럼 undefined나 500이 보이면 원인을 각각 나눠서 확인해야 합니다. 🪄 2. 문제를 격리하고 좁히기문제가 발생한 부분만 따로 실행해 최소 재현을 시도합니다.예: company_idx 값이 잘 넘어가는지 console.log()로 찍어 확인하거나, API를 Postman으로 따로 호출해 테스트합니다. 🔍 3. 정상 흐름과 문제 흐름 비교정상 동작과 문제 동작을 순서대로 비교합니다.예시: ✅ 정상: 클릭 → company_idx 값 전달 → API 200 → 화면 렌더링 ❌ 문제: 클릭 → company_idx undefined → API 400 → 렌더링 실패 📚 4. 공식 문서와 자료 활용Vue 3 DocsVue Router DocsNode.js Docs 🧰 5. 디버깅 도구 적극 활용Vue:Vue DevTools로 상태 확인Network 탭에서 HTTP 요청/응답 확인Node.js:터미널 로그 출력Postman으로 API 요청 테스트 📝 6. 기록하기이 사례처럼 스크린샷과 함께 블로그에 기록해 두면 큰 자산이 됩니다. 🪧 요약 다이어그램 [문제 발견] ↓ [에러 메시지 분석] ↓ [문제 격리 → 최소 재현] ↓ [정상/문제 흐름 비교] ↓ [문서 &amp; 자료 참고 → 도구 활용] ↓ [해결 &amp; 기록] ㅍㅍㅍㅍㅍ ✍️ 마치며실제 프로젝트에서 발생한 버그를 차근차근 좁혀가며 해결해 나가면 개발 실력도 함께 성장합니다.여러분도 자신만의 디버깅 루틴을 만들어 보세요. 참고하면 좋을 자료: https://www.youtube.com/watch?v=rHgYy7JrP1c ​ " }, { "title": "[매일매일] 백엔드 기술 일기:연속 메모리 할당 기법이란? 운영체제 메모리 관리 기초 정리", "url": "/jekyll/update/2025/07/07/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-%EC%97%B0%EC%86%8D-%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9-%EA%B8%B0%EB%B2%95%EC%9D%B4%EB%9E%80-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-07 11:17:10 +0900", "content": "운영체제에서 프로세스에 메모리를 할당하는 방식에는 여러 가지가 있습니다.그중 가장 기본적이고 직관적인 방식이 바로 연속 메모리 할당 기법 (Continuous Memory Allocation) 입니다.이 글에서는 연속 메모리 할당 기법의 개념부터, 단편화 문제, 그리고 대표적인 배치 전략까지 정리해보겠습니다. 🖋️ 연속 메모리 할당 기법이란?연속 메모리 할당 기법은 말 그대로,프로세스에 메모리의 연속된 블록을 할당하는 방식입니다.즉, 하나의 프로세스는 메모리 공간 내에서 연속된 주소 범위에만 존재하게 됩니다.​✅ 장점구현이 간단하고 관리가 쉽습니다.할당된 메모리가 연속적이라 접근 속도가 빠릅니다.❌ 단점메모리 단편화 문제가 발생하기 쉽습니다.연속된 큰 공간이 필요하기 때문에 유연성이 떨어질 수 있습니다. 🖋️ 고정 크기 할당 vs 가변 크기 할당연속 메모리 할당에는 두 가지 주요 방식이 있습니다.​🔷 고정 크기 할당 (Fixed Partitioning)메모리를 고정된 크기로 여러 파티션으로 나누어 각 프로세스에 할당.파티션보다 작은 프로세스는 남는 공간이 생겨 내부 단편화 발생.​🔷 가변 크기 할당 (Variable Partitioning)프로세스가 요청한 크기만큼 메모리를 할당.내부 단편화는 없지만, 여러 번 할당/해제가 반복되면 빈 공간이 흩어져 외부 단편화 발생. 🖋️ 단편화 문제연속 메모리 할당의 가장 큰 문제는 메모리 단편화입니다.단편화에는 두 가지가 있습니다.​📌 내부 단편화 (Internal Fragmentation)할당된 파티션 크기 &gt; 프로세스 크기 → 남는 메모리 낭비.주로 고정 크기 할당에서 발생.​📌 외부 단편화 (External Fragmentation)사용되지 않는 빈 공간들이 여기저기 흩어져 있어,충분한 총 메모리가 남아 있어도 연속된 공간이 없어 할당 불가.주로 가변 크기 할당에서 발생. 🖋️ 배치 전략: 어디에 프로세스를 배치할까?메모리에 여러 빈 공간이 있을 때, 프로세스를 어느 위치에 배치할지 선택하는 전략이 있습니다.​🔷 최초 적합 (First Fit)메모리를 순서대로 검색해, 처음으로 프로세스를 넣을 수 있는 공간에 배치.속도가 빠르고 구현이 간단하지만, 단편화가 심해질 수 있습니다.🔷 최적 적합 (Best Fit)모든 빈 공간을 탐색해, 프로세스가 들어갈 수 있는 가장 작은 공간에 배치.메모리 낭비를 최소화하지만 탐색 시간이 오래 걸립니다.🔷 최악 적합 (Worst Fit)모든 빈 공간을 탐색해, 프로세스가 들어갈 수 있는 가장 큰 공간에 배치.큰 공간을 쪼개어 남은 공간을 활용하려는 전략이지만, 효과는 미미한 경우가 많습니다. 🖋️ 더 알아보기💡 참고 자료:https://www.youtube.com/watch?v=bNFLpMUYqSE https://wikidocs.net/232217 08-4 메모리 할당방식 [TOC] ### 연속 메모리 할당 연속 메모리 할당 방식에서는 프로세스가 메모리 내에서 연속적인 주소 공간을 차지합니다. 이 방식은 메모리를 효율적으로 사용하고 관리하는 데… wikidocs.net ✍️ 마치며연속 메모리 할당 기법은 기본적이지만, 메모리 단편화라는 근본적인 한계가 있어현대의 운영체제에서는 주로 페이징과 ​세그멘테이션 같은 더 발전된 기법을 사용합니다.하지만 기본 개념을 이해하는 것은 매우 중요하니 꼭 익혀두시길 추천합니다! 😊​참고 및 출처:https://hotechstory.tistory.com/160 운영체제 - 페이징과 세그먼테이션 세그멘테이션(Segmentation)세그멘테이션은 메모리 관리 기법 중 하나로 메모리의 효율적인 사용과 프로그램의 보다 유연한 배치를 가능하게 해 준다. 세그멘테이션은 주소 공간을 논리적으로 분할하여 각각의 세그먼트에 대해 대해 별도의 베이스와 바운드 쌍을 할당하여 메모리 관리 장치에 저장하는 방식이다. 세그먼트(Segment)세그먼트는 특정 길이를 가지는 연속적인 주소 공간을 나타내며 일반적으로는 코드, 스택 및 힙 등과 같이 프로그램이나 데이터의 논리적인 부분을 나타낸다. 세그멘테이션을 사용하면 운영 체제는 각 세그먼트를 메모리… hotechstory.tistory.com ​ " }, { "title": "[매일매일] 프론트엔드 기술 일기: CSS 전처리기란? 그리고 Zero Runtime CSS와의 차이", "url": "/jekyll/update/2025/07/04/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-CSS-%EC%A0%84%EC%B2%98%EB%A6%AC%EA%B8%B0%EB%9E%80-%EA%B7%B8%EB%A6%AC%EA%B3%A0-Zero-Runtime-CSS%EC%99%80%EC%9D%98-%EC%B0%A8%EC%9D%B4.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-04 16:35:23 +0900", "content": "안녕하세요! 오늘은 프론트엔드 개발자라면 꼭 한 번은 접하게 되는 개념인 CSS 전처리기와 최근 트렌드인 Zero Runtime CSS의 차이에 대해 알아보겠습니다.CSS를 더 효율적이고 체계적으로 작성하기 위한 도구들에 대해 정리해볼게요. 🎨 CSS 전처리기란?CSS 전처리기(CSS Preprocessor)는 CSS를 더 프로그래밍스럽게 작성할 수 있게 도와주는 도구입니다.CSS는 기본적으로 선언적이고 단순한 문법을 제공하지만,✅ 변수 사용 불가✅ 코드 재사용 어려움✅ 조건문/반복문 불가등의 단점이 있습니다.CSS 전처리기는 이런 단점을 극복하기 위해 등장했습니다.CSS 전처리기를 사용하면 변수, 믹스인, 중첩, 함수 등을 사용할 수 있고, 작성한 코드를 일반 CSS로 컴파일하여 브라우저에서 사용합니다.​대표적인 전처리기Sass (SCSS): 가장 널리 사용되는 전처리기Less: 초기 도입이 빠른 전처리기Stylus: 문법이 유연한 전처리기 📄 예시 코드 비교💻 일반 CSS .primary-button { background-color: #007bff; color: white; padding: 10px 20px; border-radius: 4px; } .secondary-button { background-color: #6c757d; color: white; padding: 10px 20px; border-radius: 4px; } 💻 Sass (SCSS) $button-padding: 10px 20px; $border-radius: 4px; @mixin button($bg-color) { background-color: $bg-color; color: white; padding: $button-padding; border-radius: $border-radius; } .primary-button { @include button(#007bff); } .secondary-button { @include button(#6c757d); } 전처리기를 사용하면 반복되는 코드를 줄이고, 유지보수하기 좋은 구조로 작성할 수 있습니다. ⚖️ Zero Runtime CSS와의 차이CSS 전처리기와 Zero Runtime CSS는 모두 컴파일 타임에 CSS를 생성한다는 공통점이 있지만, 등장 배경과 목적이 다릅니다. CSS 전처리기 Zero Runtime CSS 목적 CSS의 한계 극복 CSS-in-JS의 성능 문제 해결 등장 배경 변수, 함수, 중첩 등 프로그래밍적 기능 제공 런타임 연산 제거로 성능 최적화 문법 CSS와 유사한 확장 문법 JS 기반 문법 스타일링 패러다임 전통적인 전역 스타일 컴포넌트 중심 스타일링 Zero Runtime CSS는 CSS-in-JS의 런타임 비용 문제를 해결하기 위해, 스타일을 미리 컴파일해 더 빠르고 가벼운 코드를 만들어줍니다. 📚 추천 학습 자료더 깊이 공부하고 싶다면 아래 자료를 참고해보세요!https://oneoneone.kr/content/c9f3792f CSS 전처리기: 종합적인 비교 | 일일일 🙋 추천 이유 - CSS 전처리기를 선택하는 데 어려움을 겪고 있는 개발자에게 추천합니다. - 프로젝트에 적합한 전처리기를 선택할 때 이 링크를 통해 각 전처리기의 장단점을 비교할 수 있습니다. ### ✅ 간단 요약 - Sass, SCSS, Less, Stylus의 주요 기능과 사용 사례를 설명합니다. - 각 전처리기의 문법 차이와 성능을 비교하여 적합한 선택을 돕습니다. - 프로젝트 요구 사항에 따라 최적의 전처리기를 선택하는 방법을 제시합니다. oneoneone.kr https://www.youtube.com/watch?v=Eim11QYLfEY 🌱 마무리CSS 전처리기는 더 깔끔하고 유지보수하기 좋은 CSS를 작성하기 위해 필수적으로 사용되던 도구입니다.최근에는 CSS-in-JS, Zero Runtime CSS와 같은 새로운 스타일링 방식이 트렌드가 되고 있지만, 여전히 많은 프로젝트에서 전처리기를 사용하고 있습니다.각 도구의 장단점을 이해하고, 프로젝트 상황에 맞게 선택하는 것이 중요합니다! ✍️ 오늘도 좋은 코드, 가벼운 CSS와 함께하는 하루 되세요!궁금한 점은 댓글로 남겨주세요. 😊 ​ " }, { "title": "[매일매일] 백엔드 기술 일기: 자바에서 클래스 정보를 알아내는 방법 — Reflection API란?", "url": "/jekyll/update/2025/07/04/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-%EC%9E%90%EB%B0%94%EC%97%90%EC%84%9C-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EC%95%8C%EC%95%84%EB%82%B4%EB%8A%94-%EB%B0%A9%EB%B2%95-Reflection-API%EB%9E%80.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-04 16:27:06 +0900", "content": "안녕하세요! 오늘은 자바 백엔드 개발을 공부하면서 꼭 한 번쯤 접하게 되는 Reflection API에 대해 정리해보았습니다.프레임워크 내부 동작을 이해하거나, 동적으로 클래스에 접근할 때 유용하게 쓰이는 기술입니다. 📌 자바에서 클래스 정보를 알아내는 방법자바에서는 프로그램 실행 중에 클래스에 대한 정보를 얻고, 동적으로 메서드 호출이나 필드 접근을 할 수 있습니다.이때 사용하는 것이 바로 Reflection API입니다.Reflection API는 java.lang.reflect 패키지에 포함되어 있고,대표적으로 아래와 같은 클래스를 제공합니다.Class: 클래스 자체를 표현Method: 클래스가 가진 메서드를 표현Field: 클래스가 가진 필드를 표현덕분에 코드를 작성할 때 구체적인 타입을 몰라도, 런타임에 클래스의 구조에 접근할 수 있습니다.주로 프레임워크나 라이브러리에서 많이 사용되는데, 대표적으로 Spring의 DI 컨테이너나 JPA가 내부적으로 Reflection을 활용합니다. 🧩 Reflection API의 장점Reflection의 가장 큰 강점은 동적 처리입니다.✅ 런타임에 클래스 타입을 몰라도, 메서드/필드에 접근 가능✅ 사용자 입력이나 외부 설정에 따라 동적으로 메서드 실행 가능✅ 프록시 객체 생성, DI, AOP 등에 유용예를 들어, 다음과 같이 메서드를 동적으로 호출할 수 있습니다. Class&lt;?&gt; clazz = Class.forName(“com.example.MyClass”); Method method = clazz.getMethod(“sayHello”); method.invoke(clazz.getDeclaredConstructor().newInstance()); ⚠️ Reflection API의 단점하지만, Reflection은 몇 가지 단점도 있습니다.❌ 코드가 복잡해지고, 가독성이 떨어질 수 있습니다.❌ 캡슐화가 약화됩니다. (private 필드도 강제로 접근 가능)❌ 성능 저하가 발생할 수 있습니다. (JIT 최적화가 어려워짐)특히, 성능 문제는 최신 JVM에서는 크게 문제되지 않는 경우도 있지만, 대량으로 호출할 경우에는 유의해야 합니다. 🌱 마무리Reflection API는 자바를 더욱 유연하게 만들 수 있는 강력한 도구입니다.하지만 남용하면 유지보수가 어려워지고 성능이 떨어질 수 있기 때문에, 꼭 필요한 상황에서만 신중하게 사용하는 것이 좋습니다. 📚 추천 학습 자료더 깊이 공부하고 싶다면 아래 자료를 추천드립니다!​이미지 출처:https://www.geeksforgeeks.org/java/reflection-in-java/ Reflection in Java - GeeksforGeeks Your All-in-One Learning Portal: GeeksforGeeks is a comprehensive educational platform that empowers learners across domains-spanning computer science and programming, school education, upskilling, commerce, software tools, competitive exams, and more. www.geeksforgeeks.org 🎥 [10분 테코톡] 파랑, 아키의 리플렉션https://www.youtube.com/watch?v=67YdHbPZJn4 📝 [테코블] Reflection API 간단히 알아보자https://tecoble.techcourse.co.kr/post/2020-07-16-reflection-api/ Reflection API 간단히 알아보자. Spring Framework를 학습하다 보면 Java Reflection API를 자주 접하게 된다. 하지만 Reflection API… tecoble.techcourse.co.kr 🎥 [백기선님 유튜브] 자바, 리플렉션https://www.youtube.com/watch?v=Q-8FC09OSYg 📄 Oracle Java Magazine — Reflection for the modern Java programmerhttps://blogs.oracle.com/javamagazine/post/java-reflection-introduction Reflection for the modern Java programmer Take advantage of the rich metadata the Java compiler provides to the JVM. blogs.oracle.com 📄 Oracle Java Magazine — The performance implications of Java reflectionhttps://blogs.oracle.com/javamagazine/post/java-reflection-performance The performance implications of Java reflection Reflection slows down your Java code. Why is that? blogs.oracle.com ✍️ 오늘도 성장하는 하루 되세요!궁금한 점이 있으면 댓글로 남겨주세요. 😊 혹시 이 내용을 Markdown 파일이나 이미지 카드형 요약으로도 만들어 드릴까요? 원하시면 말씀해주세요! 🌟 " }, { "title": "[매일매일] 테스트 더블(Test Double) 완전 정복", "url": "/jekyll/update/2025/07/03/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8D%94%EB%B8%94-Test-Double-%EC%99%84%EC%A0%84-%EC%A0%95%EB%B3%B5.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-03 08:32:43 +0900", "content": "단위 테스트에서 외부 의존성을 어떻게 다룰 것인가? ✨ 들어가며백엔드 개발을 하다 보면 DB, 외부 API, 메시지 큐, 파일 시스템 같은 의존성이 많습니다. 이런 의존성들과 함께 테스트를 작성하면 테스트가 느려지거나 불안정해질 수 있는데요, 이를 해결하기 위해 등장한 것이 바로 테스트 더블(Test Double) 입니다. 🧩 테스트 더블이란? 테스트 더블은 테스트 대상 객체가 의존하는 컴포넌트를 대신하는 “가짜 객체” 입니다. 실제 의존성을 그대로 사용하는 테스트는 다음과 같은 문제를 유발할 수 있습니다.외부 API 서버가 다운되면 테스트 실패DB 초기화가 번거롭고 느림복잡한 설정을 테스트마다 반복→ 테스트 더블을 사용하면 성능 개선, 결정성 보장, 단순화된 설정이 가능해집니다. 🔍 테스트 더블의 5가지 종류 종류 설명 주 사용 목적 더미 (Dummy) 아무 동작도 하지 않는 객체 매개변수 채우기용 스텁 (Stub) 미리 정의된 값을 반환 조건 충족, 흐름 제어 페이크 (Fake) 실제처럼 동작하지만 간단한 구현 인메모리 DB 등 스파이 (Spy) 어떤 메서드가 호출됐는지 기록 호출 횟수 검증 목 (Mock) 행위 기반 검증, 기대한 대로 안 되면 실패 TDD의 검증 중심 테스트 🪵 Dummy (더미) @Test void createUser() { Logger dummyLogger = new DummyLogger(); // 아무 일도 하지 않음 UserService service = new UserService(dummyLogger); service.create(“Alice”); } 단순히 null이 아닌 객체가 필요할 때 사용호출되더라도 아무 동작도 하지 않음 📦 Stub (스텁) class StubEmailService implements EmailService { public boolean sendEmail(String to) { return true; // 항상 성공한 척 } } 특정 조건에 따라 고정된 값을 리턴테스트 흐름 제어에 유용 🛠 Fake (페이크) class InMemoryUserRepository implements UserRepository { private Map&lt;String, User&gt; db = new HashMap&lt;&gt;(); public void save(User user) { db.put(user.getId(), user); } public User find(String id) { return db.get(id); } } 실제처럼 작동하지만 간단한 구현예: 인메모리 DB, 임시 파일 시스템테스트 속도와 독립성 ↑ 👀 Spy (스파이) class SpyEmailService implements EmailService { private boolean wasCalled = false; public boolean sendEmail(String to) { wasCalled = true; return true; } public boolean wasEmailSent() { return wasCalled; } } 호출 여부, 호출 횟수 등 “기록”결과뿐 아니라 과정도 검증 가능 🎭 Mock (목) EmailService mock = mock(EmailService.class); UserService service = new UserService(mock); service.register(“test@example.com”); // 기대한 대로 sendEmail이 호출되었는지 검증 verify(mock).sendEmail(“test@example.com”); “기대하는 상호작용”이 있었는지 확인기대에 어긋나면 테스트 실패 🧭 Classic TDD vs Mockist TDD 구분 Classic TDD Mockist TDD 중점 상태 검증 행위 검증 의존성 처리 실제 구현 or Fake 사용 Mock 객체 사용 장점 테스트 유지 보수성 ↑ 개발 속도와 경량화 ↑ 예시 “저장되었는가?” “호출되었는가?” 예: 사용자가 저장되었는지 DB.getUser()로 확인 → Classic예: repository.save()가 호출되었는지 verify() → Mockist 📝 마무리테스트 더블은 단순히 “가짜 객체”가 아니라, 테스트의 목적을 명확하게 해주는 도구입니다.✔ 복잡한 의존성을 제거하고✔ 테스트 성능과 안정성을 확보하며✔ 객체 간 상호작용까지 검증할 수 있게 도와줍니다프로젝트 성격, 테스트 목적, 팀 스타일에 따라 다양한 조합으로 활용해보세요! 📚 참고 자료 및 출https://www.youtube.com/watch?v=n01foM9tsRo https://www.youtube.com/watch?v=4q9d8Aye0nY&amp;t=2169s https://jojoldu.tistory.com/614 테스트 코드에서 내부 구현 검증 피하기 테스트 코드를 작성하고 운영하다보면 기존 코드가 조금만 변경되어도 테스트를 다 고쳐야하는 경우가 종종 있다. (모든 경우가 그렇진 않겠지만) 기능의 최종 결과를 검증하는게 아니라 내부 구현을 검증하는 경우에 자주 이런일이 있었다. 내부 구현을 검증하는 테스트들은 구현을 조금만 변경해도 테스트가 깨질 가능성이 커진다. 내부 구현은 언제든지 바뀔 수 있기 때문에 테스트 코드는 내부 구현 보다 최종 결과를 검증해야한다. 그럼, 내부 구현을 검증하는 경우란 어떤 것인지 알아보자. 1. 상세 구현부를 다 검증하는 경우 이를 테면 다음과 같이… jojoldu.tistory.com https://ysiksik.github.io/elegant-tekotok/2023-02-04-DUZ-TIKI-ClassicTDDVSMockistTDD/ 더즈, 티키의 Classic TDD VS Mockist TDD https://youtu.be/n01foM9tsRo ysiksik.github.io ​ " }, { "title": "[매일매일]Git 브랜치 전략 완전 정복!", "url": "/jekyll/update/2025/07/03/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EC%A0%84%EB%9E%B5-%EC%99%84%EC%A0%84-%EC%A0%95%EB%B3%B5.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-03 08:23:21 +0900", "content": "프로젝트에 딱 맞는 브랜치 전략, 어떻게 선택할까?​✨ 들어가며프론트엔드 개발을 하다 보면 협업과 배포 과정에서 Git 브랜치 전략의 중요성을 실감하게 됩니다. 이번 글에서는 제가 경험한 세 가지 대표적인 브랜치 전략인 Git Flow, GitHub Flow, 그리고 Trunk-Based Development를 소개하고, 각각의 장단점 및 적합한 상황에 대해 정리해보겠습니다. 📌 목차Git FlowGitHub FlowTrunk-Based Development전략 선택 기준은?마무리 및 참고 자료 🌱 Git Flow 안정성과 체계적인 릴리스 관리가 필요한 프로젝트에 적합한 전략 구조main: 프로덕션 배포용 브랜치develop: 통합 개발 브랜치feature/: 기능 개발 브랜치release/: 배포 준비용 브랜치hotfix/*: 긴급 수정 브랜치 작동 방식기능 개발은 feature/브랜치명에서 시작 → develop에 병합릴리스 직전 release/버전명 생성 → QA 진행완료 후 main과 develop 모두에 병합긴급 버그는 hotfix 브랜치 생성 → main과 develop에 반영​장점✅ QA 과정이 명확하게 분리됨✅ 대규모 팀 협업 시 안정적 운영 가능단점⚠ 브랜치가 많아져 복잡도 증가⚠ 병합 작업 많아짐 → 충돌 관리 필요 🌊 GitHub Flow 빠른 배포 주기를 가진 프로젝트에 적합한 민첩한 전략 구조main: 단일 브랜치 (프로덕션 겸용)feature/*: 기능 단위 작업 브랜치작동 방식main에서 feature/기능명 브랜치 생성작업 완료 후 PR 생성 → 코드 리뷰리뷰 완료되면 main에 병합바로 배포! 장점✅ 구조가 단순해 이해하기 쉬움✅ 빠른 피드백과 배포 가능단점⚠ QA/릴리스 분리가 없어 위험 부담 존재⚠ 실수로 배포되는 경우 방어 장치 부족 🌳 Trunk-Based Development 정말 빠르게 일하고 싶다면? trunk 기반으로! 구조main 또는 trunk: 유일한 중심 브랜치(옵션) 단기 feature 브랜치작동 방식모든 커밋은 최대한 빠르게 main에 반영feature 브랜치를 쓰더라도 1~2일 내 병합CI/CD 자동화로 릴리스 관리 장점✅ 충돌 발생 가능성 ↓ (자주 병합되므로)✅ CI/CD 기반의 자동 배포와 찰떡궁합단점⚠ 자동화/테스트 인프라가 잘 갖춰져 있어야 함⚠ 모든 팀원이 높은 커밋 품질을 유지해야 함 ⚖️ 어떤 전략을 선택해야 할까? 프로젝트 상황 추천 전략 QA 필수, 릴리스 주기 길다 Git Flow 빠른 배포와 반복이 중요 GitHub Flow CI/CD 자동화 기반, 초단기 배포 Trunk-Based Development 저는 하나의 전략을 고집하기보다는 프로젝트 상황에 따라 전략을 유연하게 적용하는 편입니다. 예를 들어, 금융/공공 시스템처럼 안정성이 중요한 프로젝트는 Git Flow가 좋고, 스타트업처럼 민첩함이 필요한 환경에서는 GitHub Flow가 훨씬 효율적입니다. 📚 참고 자료 및 출처[10분 테코톡] 렉스의 Git 브랜칭 전략https://www.youtube.com/watch?v=wtsr5keXUyE [Git Flow에서 Trunk 기반 개발로 나아가기 (우아한테크코스 블로그)]https://tech.mfort.co.kr/blog/2022-08-05-trunk-based-development/ Git Flow에서 트렁크 기반 개발으로 나아가기 - 맘시터 기술블로그 트렁크 기반 개발 방식으로 나아가며 배운 점들을 공유합니다. tech.mfort.co.kr 📝 마무리하며Git 브랜치 전략은 단순한 기술이 아니라 협업 문화와 품질을 결정짓는 설계입니다. 프로젝트 성격, 팀 규모, 배포 주기를 고려해 전략을 선택하고, 필요하다면 하이브리드로 조정하는 것도 좋은 방법입니다.​ " }, { "title": "[매일매일] 프론트엔드 기술 일기: 모노레포(Monorepo) 개념과 활용 정리", "url": "/jekyll/update/2025/07/02/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-%EB%AA%A8%EB%85%B8%EB%A0%88%ED%8F%AC-Monorepo-%EA%B0%9C%EB%85%90%EA%B3%BC-%ED%99%9C%EC%9A%A9-%EC%A0%95%EB%A6%AC.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-02 13:54:18 +0900", "content": "오늘은 프론트엔드에서 점점 더 중요해지고 있는 모노레포(Monorepo) 개념에 대해 정리해본다. 최근 팀 프로젝트나 규모가 커진 프론트엔드 시스템에서 점점 더 많이 활용되고 있어, 실무와 면접 모두에서 유용하게 쓰일 개념이다. 🧩 모노레포란?Monorepo = Mono(단일) + Repo(저장소)모노레포는 여러 개의 프로젝트(또는 패키지)를 하나의 Git 저장소에서 함께 관리하는 방식이다. 예를 들어 admin, landing, mobile, shared-ui처럼 여러 앱과 공통 패키지를 하나의 저장소에서 구조적으로 나누어 관리하는 방식이다. 🏗️ 구성 방식 요약앱 단위 분리: apps/ 폴더 안에 각 프로젝트를 위치시켜 분리한다.공통 모듈 공유: packages/나 libs/ 폴더에 유틸, 공통 컴포넌트 등을 관리하고 각 앱에서 재사용한다.워크스페이스 활용: yarn workspaces, npm workspaces, pnpm workspace를 통해 의존성을 루트에서 관리하며 중복 제거 및 빌드 최적화가 가능하다. my-monorepo/ ├── apps/ │ ├── frontend/ │ └── admin/ ├── packages/ │ ├── ui/ │ └── utils/ ├── package.json ├── turbo.json or nx.json ✅ 장점 정리코드 일관성 유지: ESLint, Prettier, tsconfig 등 설정을 통일해서 관리 가능공통 모듈 재사용: 한 번 작성한 유틸/컴포넌트를 여러 프로젝트에 반영 가능버전 관리 최적화: Git 히스토리로 어느 변경이 어떤 프로젝트에 영향을 줬는지 추적 가능CI/CD 속도 개선: 변경된 프로젝트만 빌드하거나 테스트하도록 구성 가능 (Turborepo, Nx 등 사용 시) ⚠️ 단점 및 주의점스케일링 복잡성: 프로젝트가 많아질수록 빌드 및 테스트 시간이 길어질 수 있음권한 관리 어려움: 저장소 단위로 권한을 설정하므로 프로젝트별 접근 제한이 어려움소규모에는 과한 구조: 단일 프로젝트 또는 소규모 팀에서는 오히려 비효율적일 수 있음 🛠️ 모노레포 관리 툴 툴 이름 특징 Turborepo 빠른 캐싱, 병렬 빌드, Vercel 제작 Nx 다양한 프레임워크 지원, Graph 시각화 기능 Lerna 오래된 툴, 요즘은 보조 도구로 사용 💡 실무와 면접에서 활용하기 “왜 모노레포를 선택하셨나요?”라는 질문이 자주 등장함 예시 답변 “여러 앱과 공통 UI를 재사용하는 프로젝트에서, 공통 컴포넌트 수정 시 각 앱에 동기화하는 게 비효율적이었습니다. 그래서 모노레포 구조로 변경했고, yarn workspace를 통해 의존성을 통합 관리하면서 유지보수가 훨씬 쉬워졌습니다.” 📚 참고 자료 및 출처https://medium.com/hcleedev/dev-monorepo-%EA%B0%9C%EB%85%90-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-33fd3ce2b767 Dev: MonoRepo 개념 알아보기 여러 프로젝트를 한 레포지토리에서 관리하는 MonoRepo의 개념과 그 장단점에 대해 알아보자 medium.com https://fromundefined.com/posts/2022-08-ultimate-monorepo/ 궁극의 JavaScript 모노레포 설정 - fromundefined by Tony 제가 정착한 궁극의 JavaScript 모노레포 설정에 대해서 소개합니다. fromundefined.com https://fastcampus.co.kr/story_article_newfefinal 주니어 프론트엔드 개발자라면 놓치지 말아야 할 모노레포에 대해 알아보자 | 패스트캠퍼스 프론트엔드 개발이 날이 갈수록 빠르게 발전하면서 다양한 기술과 접근법이 등장하고 있습니다. 그 중 최근 가장 주목받는 트렌드인 ‘모노레포(Monorepo)’에 대해 알아보고, 모노레포의 가장 효과적인 공부 방법에 대해 알아봅시다. fastcampus.co.kr ​ " }, { "title": "면접 Tip: 배포 전략 + 상황 판단 + 근거 있는 선택", "url": "/jekyll/update/2025/07/02/%EB%A9%B4%EC%A0%91-Tip-%EB%B0%B0%ED%8F%AC-%EC%A0%84%EB%9E%B5-%EC%83%81%ED%99%A9-%ED%8C%90%EB%8B%A8-%EA%B7%BC%EA%B1%B0-%EC%9E%88%EB%8A%94-%EC%84%A0%ED%83%9D.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-02 13:45:47 +0900", "content": "면접 답변은 아래 3단계 구조로 말하면 좋습니다: [1] 상황 설명 → [2] 어떤 배포 방식 선택 → [3] 이유 및 결과 ✅ 롤링 배포 (Rolling Deployment)🧪 실무 예시:ESG HR 시스템에서 프론트엔드 요청 방식이 바뀌는 작은 변경이 있었음모든 서버를 동시에 바꾸면 리스크가 크므로, 서버 1대에만 우선 반영사용자 요청 로그를 DEBUG 수준으로 기록하며 오류 유무를 점검💬 면접 답변 예시: “작은 기능 수정이나 버그 수정 시에는 롤링 배포를 사용했습니다.ESG 플랫폼에서 프론트 요청 방식이 바뀌었는데, 먼저 1대 서버에만 반영해 테스트하고, 로그를 통해 오류 유무를 확인한 뒤 다른 서버에 순차 배포했습니다.덕분에 다운타임 없이 안정적으로 반영할 수 있었고, 문제가 발생해도 빠르게 대응 가능했습니다.” ✅ 블루/그린 배포 (Blue/Green Deployment)🧪 실무 예시:전체 구조 리팩토링 (e.g. MongoDB → PostgreSQL 전환)서비스 중단 없이 마이그레이션을 위해 새 서버 환경을 구성트래픽을 한 번에 Green 환경으로 전환한 뒤, Blue는 롤백 대비 유지💬 면접 답변 예시: “대규모 구조 변경이 필요했던 프로젝트에서 블루/그린 배포를 적용했습니다.기존 환경(Blue)을 유지하면서 새로운 스펙의 서버(Green)에 먼저 배포하고, 충분히 검증한 뒤 트래픽을 스위칭했습니다.이후 문제가 없음을 확인하고 Blue를 폐기했습니다. 롤백 대비도 가능해 안정적인 배포였습니다.” ✅ 카나리 배포 (Canary Deployment)🧪 실무 예시:새로운 UI 기능(A/B 테스트) 추가전체 유저 중 10%에게만 노출되도록 트래픽 분산전환율, 클릭률 등 통계를 기반으로 효과를 검증💬 면접 답변 예시: “UI 개선 A/B 테스트를 위해 카나리 배포를 사용했습니다.신규 기능이 포함된 서버에 트래픽을 10%만 보내고, 사용자 반응(이탈률, 클릭률 등)을 비교 분석했습니다.결과가 긍정적이어서 점차 트래픽을 확대했고, 전체 반영까지 성공적으로 마무리했습니다.” 📝 정리표: 배포 방식별 면접 활용 요약 배포 방식 추천 상황 면접 키워드 롤링 배포 비용 민감, 작은 변경 순차적, 로그 확인, 다운타임 없음 블루/그린 대규모 리팩토링, 완전 전환 새 서버 환경, 빠른 롤백 카나리 배포 테스트, 사용자 반응 체크 퍼센트 분산, 통계 기반 판단 " }, { "title": "[매일매일]백엔드 기술 일기: 무중단 배포(Zero-Downtime Deployment)란?", "url": "/jekyll/update/2025/07/02/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EB%B0%B0%ED%8F%AC-Zero-Downtime-Deployment-%EB%9E%80.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-02 13:42:58 +0900", "content": "무중단 배포란 말 그대로 서비스를 중단하지 않고 새로운 애플리케이션 버전을 배포하는 방식입니다. 사용자 입장에서는 배포 중이라는 사실조차 모를 정도로 자연스럽게 서비스가 이어지는 것이 핵심입니다.배포 과정에서 발생할 수 있는 서버 오류나 응답 지연, 트래픽 오류 등을 최소화하여 고가용성(High Availability)과 서비스 안정성을 보장합니다. 🧠 왜 무중단 배포가 중요할까?❌ 사용자가 오류 메시지를 보는 순간 이탈 가능성 증가❌ 다운타임 동안의 데이터 손실 또는 요청 누락🔁 빠른 롤백과 테스트 대응 필요📈 CI/CD 자동화가 일반화되면서 무중단 배포는 거의 필수 전략 📦 대표적인 무중단 배포 전략 3가지1. 🎯 롤링 배포 (Rolling Deployment) 서버를 순차적으로 하나씩 업데이트하는 방식 ✅ 서버 한 대씩 새 버전으로 업데이트❗ 업데이트 중인 서버는 일시적으로 트래픽 처리 불가🔁 두 버전이 공존하므로 하위 호환성 필요💡 활용 예시:비용이 민감한 프로젝트, 작은 패치나 버그 수정 시👉 “서버 10대 중 1대만 우선 수정 후 로그로 확인 → 이상 없으면 나머지 순차 배포” 🟦🟩 블루/그린 배포 (Blue/Green Deployment) 기존 서버(Blue)와 새 서버(Green)를 동시에 운영하고, 트래픽을 전환하는 방식 ✅ 새 서버를 미리 준비한 뒤 트래픽을 스위칭🔁 빠른 롤백 가능 (기존 서버 유지 중)💸 새로운 서버를 미리 구성해야 해서 비용이 큼​💡 활용 예시:대규모 업데이트, 기술 스택 전환 등👉 “기술 부채 청산 후 전체 인프라를 새로운 서버에 배포” 🐤 카나리 배포 (Canary Deployment) 새 버전을 일부 사용자만 먼저 사용하도록 하고, 점진적으로 트래픽을 확장하는 방식 ✅ 트래픽을 비율로 분산 (ex. 신규 서버 10% → 30% → 100%)📊 오류율, 성능 통계를 통해 효과적인 검증 가능🔁 롤링 배포처럼 두 버전이 공존 → 하위 호환 고려💡 활용 예시:A/B 테스트, 통계 기반 검증, 실시간 사용자 반응 체크👉 “신규 기능의 반응이 궁금할 때, 카나리로 30% 사용자만 먼저 사용” 🧭 어떤 배포 전략을 선택해야 할까? 상황 추천 배포 방식 비용 제약 있음, 작은 수정 배포 🔁 롤링 배포 대규모 업데이트, 큰 변화 🟦🟩 블루/그린 배포 통계 기반 기능 검증, A/B 테스트 🐤 카나리 배포 📚참고 및 출처https://www.youtube.com/watch?v=kgvBlruQEKU https://hudi.blog/zero-downtime-deployment/ 무중단 배포 아키텍처와 배포 전략 (Rolling, Blue/Green, Canary) 무중단 배포 아키텍처와 배포 전략 (Rolling, Blue/Green, Canary) @ Hudi · August 29, 2022 · 3 min read 배포 중단 배포 방식과 다운타임 다운타임 서버 한대로 서비스를 운영한다고 가정해보자. 현재 서버에는 V1 버전이 실행되고 있는 상황이다. 그리고 우리는 이번에 여러 기능을 추가한 V2 버전을 새로 개발했다. 이제 사용자들이 V2 버전을 사용할 수 있도록 배포해야한다. 배포를 하려면 어떤 과정을 거쳐야할까? 일단 새로 만든 V2 버전 빌드를 서버에 다운로드 해야한다. V1 버전과 … hudi.blog ​ " }, { "title": "[매일매일] 프론트 엔드 기술 일기: image 요소의 alt 속성은 어떤 목적으로 사용하나요?", "url": "/jekyll/update/2025/07/01/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%ED%94%84%EB%A1%A0%ED%8A%B8-%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-image-%EC%9A%94%EC%86%8C%EC%9D%98-alt-%EC%86%8D%EC%84%B1%EC%9D%80-%EC%96%B4%EB%96%A4-%EB%AA%A9%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%82%98%EC%9A%94.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-01 15:27:32 +0900", "content": "​🖼️ img 태그의 alt 속성, 단순 설명이 아니다?! 웹 접근성, 사용자 경험, SEO까지 챙기는 필수 속성alt 속성은 왜 중요할까? ✅ 1. alt 속성의 정의HTML의 태그에 사용되는 alt 속성은이미지의 ​대체 텍스트(alternative text) 를 의미합니다. 이 속성은 이미지를 시각적으로 볼 수 없을 때, 사용자나 검색 엔진, 보조 기술이 이미지의 의미를 이해할 수 있도록 돕는 역할을 합니다. 🔍 2. 어떤 상황에서 필요할까?🖼️ 이미지가 로드되지 않을 때네트워크 오류나 경로 문제 등으로 이미지가 나타나지 않으면 alt 텍스트가 대신 표시되어 의미 전달 가능​🧑‍🦯 스크린 리더 사용자에게 설명 제공시각장애인 사용자는 이미지를 보지 못하므로, alt 텍스트를 음성으로 안내받아 이미지 내용을 이해​🔎 검색 엔진 최적화(SEO)Google과 같은 검색 엔진은 이미지 자체를 이해하지 못하기 때문에 alt 속성에 작성된 텍스트를 분석해 이미지의 의미를 파악함관련 키워드를 포함하면 이미지 검색 최적화 효과도 있음 🎯 3. 꼭 모든 이미지에 alt 속성을 써야 할까?✅ 의미 있는 콘텐츠 이미지반드시 alt 속성 제공예: 제품 사진, 인포그래픽, 인물 사진 등 🚫 장식용/디자인용 이미지alt 속성은 비워두는 것이 좋음alt=”“로 처리하면 스크린 리더가 해당 요소를 건너뜀 ​ ❗️의미 없는 이미지에 alt를 잘못 작성하면 오히려 사용자 혼란 유발 가능 💡 실무에서 자주 하는 실수 실수 이유 바른 사용 예 alt 생략 접근성/SEO에 치명적 항상 작성하되 목적에 맞게 alt에 파일명 사용 의미 없음 alt=”제품 박스에 담긴 텀블러” alt에 과도한 키워드 삽입 SEO 스팸 간주 위험 자연스러운 문장형 텍스트 추천 📌 추가 학습 자료https://developer.mozilla.org/ko/docs/Web/HTML/Reference/Elements/img#alt : 이미지 삽입 요소 - HTML: Hypertext Markup Language | MDN HTML 요소는 문서에 이미지를 넣습니다. developer.mozilla.org https://brunch.co.kr/@snclab/2 대체 텍스트 올바르게 제공하기- 1편 오류 유형으로 살펴보는 웹 접근성 지침 | 오류유형1. 이미지 요소의 alt 속성 제공 웹사이트에 이미지를 표현하고 싶을 때 여러 가지 방법을 이용할 수 있습니다. 그 중 가장 기본적이며, 흔하게 사용되는 방법이 , &lt;input type=”image”&gt;와 같은 HTML 이미지 요소(element)의 사용일 것입니다. alt 속성(attribute)은 이러한 이미지 요소를 대체할 수 있는 텍 brunch.co.kr ✍️ 마무리단순히 “설명을 위한 속성”이라고 생각했던 alt​,사실은 접근성과 검색 최적화, UX까지 고려한 핵심 속성입니다.적절한 alt 작성은 누구나 접근 가능한 웹을 만드는 첫걸음입니다!​ " }, { "title": "[매일매일] 백엔드 기술 일기: 분산 환경에서 Redis를 활용한 잠금은 어떻게 구현할까?", "url": "/jekyll/update/2025/07/01/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-%EB%B6%84%EC%82%B0-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-Redis%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%9E%A0%EA%B8%88%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B5%AC%ED%98%84%ED%95%A0%EA%B9%8C.html", "categories": "jekyll, update", "tags": "", "date": "2025-07-01 15:10:22 +0900", "content": "다수의 서버가 동시에 하나의 자원에 접근하지 않도록 제어할 수 있을까?Redis의 분산 잠금 기법과 RedLock 알고리즘을 통해 알아보자! ✅ 1. 왜 분산 잠금이 필요할까?​분산 시스템에서는 여러 서버에서 동일한 리소스(예: 재고, 계좌, 주문 등)에 동시에 접근할 수 있기 때문에, 경쟁 상태(Race Condition)를 방지하기 위한 잠금(Lock) 메커니즘이 필요합니다.단일 서버에서는 자바의 synchronized나 DB의 SELECT FOR UPDATE 같은 방법으로 제어할 수 있지만,분산 환경에서는 모든 서버가 공유할 수 있는 저장소(예: Redis)를 활용한 잠금이 필요합니다. 🔧 2. Redis를 활용한 기본적인 분산 잠금Redis는 다음과 같은 명령어 조합으로 분산 잠금을 구현할 수 있습니다: SET lock_key unique_value NX EX 10 NX: Key가 존재하지 않을 때만 설정EX: 만료 시간 설정 (예: 10초)unique_value: 요청한 서버를 식별할 수 있는 UUID 등 이 명령어는 “만약 락이 존재하지 않으면 생성하고, 10초 뒤에는 자동으로 만료”라는 의미입니다. 🔄 잠금 해제는?잠금 해제 시에는 반드시 unique_value를 비교 후 삭제해야 합니다. if redis.call(“get”,KEYS[1]) == ARGV[1] then return redis.call(“del”,KEYS[1]) else return 0 end ​ ⚠️ 3. 단일 Redis 노드 사용의 문제점Redis를 마스터-레플리카 구조로 구성한 경우, 마스터 장애 발생 시 레플리카가 마스터로 승격되는 동안 데이터 복제가 완료되지 않으면 잠금 정보가 유실될 수 있습니다.​예시 시나리오서버 A가 잠금을 획득 (SET lock_key A)마스터 장애 → 레플리카가 마스터로 승격아직 레플리카에는 lock_key가 복제되지 않음다른 서버 B가 다시 lock_key를 획득💥 동일한 자원에 대해 중복 작업 발생 🛡️ 4. RedLock 알고리즘으로 문제 해결Redis의 창시자인 Salvatore Sanfilippo(antirez)가 제안한 RedLock 알고리즘은 위와 같은 장애 상황을 대비한 분산 락 프로토콜입니다.​RedLock 동작 방식5개의 독립된 Redis 노드에 동시에 lock 요청과반수(3개 이상)의 노드에서 lock을 획득lock 획득 시간 &lt; TTL 이내일 경우에만 유효작업이 끝난 후 모든 노드에 lock 해제​장점마스터 장애에도 락 유실 가능성 감소고가용성 보장데이터 복제 지연에 안전단점5개의 독립 Redis 인스턴스 필요 (운영 부담)네트워크 지연 및 클럭 동기화 이슈 고려 필요여전히 완벽한 해결책은 아님 (⇒ 논란 있음) 실제 운영에서는 RedLock을 그대로 쓰기보단 DB-based Lock + Redis 캐시 조합, Zookeeper 기반 Lock, 분산 트랜잭션, ETCD 같은 대안도 함께 고려합니다. 📚 참고 자료 및 출처https://redis.io/docs/latest/develop/use/patterns/distributed-locks/ Distributed Locks with Redis A distributed lock pattern with Redis redis.io https://mangkyu.tistory.com/311 [Redis] 레디스가 제공하는 분산락(RedLock)의 특징과 한계 분산락의 필요성과 레디스의 분산락(RedLock) [ 분산락의 필요성 ] 분산 환경에서는 서로 다른 클라이언트가 공유 리소스를 사용하는 경우가 많이 있다. 기본적으로 레디스(Redis)는 싱글 스레드로 동작하기 때문에, 단일 레디스 노드를 구축해 사용해도 동시성 문제가 발생하지 않는다. 따라서 리소스에 대해 값을 설정하여, 값이 설정된 경우에는 다른 리소스의 접근을 차단할 수 있다. 이를 잠금이라고 표현할 것이며, 이를 위해 다음과 같은 명령을 사용할 수 있다. // key, value를 저장하는데 NotExists일 경우에만… mangkyu.tistory.com https://helloworld.kurly.com/blog/distributed-redisson-lock/ 풀필먼트 입고 서비스팀에서 분산락을 사용하는 방법 - Spring Redisson 어노테이션 기반으로 분산락을 사용하는 방법에 대해 소개합니다. helloworld.kurly.com https://blog.wadiz.kr/%EB%B6%84%EC%82%B0-%ED%99%98%EA%B2%BD-%EC%86%8D%EC%97%90%EC%84%9C-%EB%94%B0%EB%8B%A5%EC%9D%84-%EC%99%B8%EC%B9%98%EB%8B%A4/ 분산 환경 속에서 ‘따닥’을 외치다 - 와디즈 블로그 와디즈에는 간편 카드 등록을 할 수 있어요. 오직 1개만 등록할 수 있는데 간헐적으로 중복으로 등록되는 버그, ‘따닥 이슈’가 발생했죠. 레디스 분산 락을 걸어 빈도수를 제로에 가깝게 줄였지만, 정확한 뿌리를 찾고자! 여정을 떠났습니다. blog.wadiz.kr https://channel.io/ko/blog/articles/abc2d95c Distributed Lock 구현 과정 Distributed Lock을 구현하는 여러 방법과 우리의 선택 channel.io ✍️ 마무리하며Redis를 이용한 분산 잠금은 빠르고 간편하지만, 장애 상황까지 고려한 정교한 설계가 필요합니다.RedLock은 그 한계를 보완하기 위한 좋은 접근법이지만, 사용 환경에 따라 조합 또는 대안도 검토해야 합니다.​ " }, { "title": "[매일매일]백엔드 기술일기: 데이터베이스 정규화 vs 역정규화 – 한눈에 이해하기", "url": "/jekyll/update/2025/06/30/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0%EC%9D%BC%EA%B8%B0-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%A0%95%EA%B7%9C%ED%99%94-vs-%EC%97%AD%EC%A0%95%EA%B7%9C%ED%99%94-%ED%95%9C%EB%88%88%EC%97%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0.html", "categories": "jekyll, update", "tags": "", "date": "2025-06-30 13:54:53 +0900", "content": "데이터베이스 설계에서 가장 기본이면서도 중요한 개념 중 하나가 정규화(Normalization)입니다.하지만 실무에서는 반대로 역정규화(Denormalization)가 필요한 경우도 많죠.이번 글에서는 정규화와 역정규화의 개념, 목적, 각 단계별 설명, 그리고 선택 기준까지 한 번에 정리해보겠습니다. ✅ 정규화란? “데이터 중복을 줄이고, 데이터 무결성을 높이기 위해 테이블을 구조적으로 정리하는 과정” 정규화는 삽입, 삭제, 갱신 이상(Anomaly)을 방지하고, 데이터가 일관성 있게 관리될 수 있도록 도와줍니다.여러 단계가 존재하며, 단계별로 더 정교한 구조로 분해됩니다. 🔹 1정규화 (1NF) – 원자값으로 분해설명: 모든 컬럼은 원자값(Atomic Value)만 가지도록 함예시:잘못된 예 → 취미: 독서, 등산올바른 예 → 취미: 독서, 취미: 등산 (행을 나누거나 테이블 분리) 🔹 2정규화 (2NF) – 완전 함수 종속설명: 부분 함수 종속 제거, 기본키의 일부가 아닌 전체에 종속된 속성만 남기기예시:복합키 (학생ID, 과목ID) → 교수이름 (❌)→ 교수이름은 과목에만 종속되므로 별도 테이블로 분리 🔹 3정규화 (3NF) – 이행적 종속 제거설명: A → B → C 라는 이행 종속이 있다면, A → C 관계 제거예시:학생ID → 학과코드 → 학과명→ 학과명은 별도 테이블로 분리 🔹 BCNF (보이스-코드 정규형)설명: 모든 결정자는 후보키가 되어야 함예시:강의실 → 강사, 시간표→ 강사도 키가 될 수 있다면 BCNF로 분리 필요 ❗ 역정규화란? “읽기 성능 향상을 위해 일부러 데이터 중복을 허용하고 테이블을 다시 합치는 과정” 정규화를 통해 데이터는 깔끔하게 분리되지만, 조회 시 JOIN 연산이 많아지며 성능 저하가 발생할 수 있습니다.이럴 때는 정규화된 구조를 다시 적절히 합쳐서 조회 성능을 높이는 것이 역정규화입니다. 📌 예시게시글 목록을 조회할 때, 댓글 수, 좋아요 수를 실시간 계산하지 않고 테이블에 저장사용자 정보와 주소 테이블을 JOIN하지 않고 한 테이블에 병합하여 사용​✅ 장점조회 속도 향상복잡한 JOIN 최소화​❌ 단점데이터 중복 발생삽입/수정 시 데이터 일관성 유지 어려움 🔍 정규화 vs 역정규화 비교 항목 정규화 역정규화 목적 중복 제거, 무결성 확보 조회 성능 향상 장점 구조적, 깔끔한 설계 빠른 읽기 성능 단점 JOIN 많아짐 → 느림 중복, 데이터 불일치 가능성 사용 예 ERP, 회계 시스템 게시판, 피드, 추천 시스템 🧪 언제 어떤 걸 선택할까?정규화가 기본입니다.→ 데이터 무결성이 가장 중요할 때역정규화는 성능이 중요한 경우에만 선택적으로→ 대용량 트래픽 시스템, 실시간 피드 등 📚 추가 학습 자료 및 출처🎥 [10분 테코톡] 켈리의 정규화 정리 영상→ https://www.youtube.com/watch?v=FZdr2HED5nA📝 [망나니개발자 블로그] 정규화 쉽게 이해하기→ https://mangkyu.tistory.com/47🧾 [리디 기술 블로그] ‘개발했더니 내 서재였던 건에 대하여’→ https://tech.ridicorp.com/2021/12/27/ridi-bookshelf-normalization.html​참고자료https://velog.io/@bsjp400/Database-DB-%EC%A0%95%EA%B7%9C%ED%99%94-%EB%B9%84%EC%A0%95%EA%B7%9C%ED%99%94%EB%9E%80 [Database] DB 정규화 &amp; 비정규화란? 안녕하세요. 이번 포스팅엔 DB 정규화에 대한 내용을 정리해보려고 합니다!관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스를 정규화라고 한다. 데이터베이스 정규화의 목표는 이상이 있는 관계를 재구성하여 작고 잘 조직된 관계를 생성하는 것에 있 velog.io 🧩 마무리하며정규화와 역정규화는 단순히 “좋다, 나쁘다”가 아니라 상황에 맞는 선택이 핵심입니다.백엔드 개발자라면 둘 다 능숙하게 다루고, 프로젝트의 성격에 따라 적절히 적용할 수 있어야겠죠.💬 정규화 vs 역정규화, 여러분의 선택은? " }, { "title": "[매일매일] 프론트엔드 기술 일기: Reset CSS vs Normalize CSS – 브라우저 기본 스타일 초기화 완전 정리", "url": "/jekyll/update/2025/06/30/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-Reset-CSS-vs-Normalize-CSS-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EA%B8%B0%EB%B3%B8-%EC%8A%A4%ED%83%80%EC%9D%BC-%EC%B4%88%EA%B8%B0%ED%99%94-%EC%99%84%EC%A0%84-%EC%A0%95%EB%A6%AC.html", "categories": "jekyll, update", "tags": "", "date": "2025-06-30 13:40:45 +0900", "content": "​웹 프론트엔드를 개발하다 보면, 브라우저마다 기본적으로 다르게 설정된 스타일 때문에 예상치 못한 디자인 문제를 겪는 경우가 많습니다. 이런 문제를 해결하기 위해 등장한 것이 바로 Reset CSS와 Normalize CSS입니다.이번 글에서는 두 방식의 차이점과 어떤 상황에 어떤 방법을 사용하는 것이 좋은지 정리해보겠습니다. 🔧 Reset CSS란?Reset CSS는 말 그대로 브라우저의 기본 스타일을 모두 초기화(reset) 하는 CSS입니다.브라우저는 각자 기본 스타일을 가지고 있기 때문에, h1, ul, body, a 등 다양한 요소에 자동으로 마진, 패딩, 폰트 등의 값이 적용되어 있습니다. Reset CSS는 이런 스타일들을 완전히 제거하고 모든 요소를 백지 상태로 되돌려 개발자가 처음부터 스타일을 설계할 수 있게 도와줍니다.​📌 예시 코드 /* Reset CSS 예시 */ { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; } ✅ 장점완전한 스타일 통일 가능디자인 시스템 적용 시 유리❌ 단점모든 스타일을 직접 작성해야 함초기 작업량 증가 🌱 Normalize CSS란?Normalize CSS는 브라우저 스타일의 차이만을 일관되게 보정(normalize) 해주는 CSS입니다.초기 스타일을 모두 제거하는 대신, 브라우저마다 다르게 적용된 부분만 통일시켜줍니다.예를 들어, 브라우저마다 h1 태그의 마진이 다를 수 있는데, Normalize CSS는 이런 차이만 교정하고, 기본 스타일은 최대한 유지합니다.​📌 예시 코드 /* Normalize CSS 예시 */ h1 { font-size: 2em; margin: 0.67em 0; } a { background-color: transparent; } ✅ 장점기본 스타일 유지로 자연스러운 디자인 가능빠른 개발 시작 가능❌ 단점완전한 초기화가 아니므로 일부 브라우저 차이는 남을 수 있음 🤔 어떤 걸 써야 할까? 기준 Reset CSS Normalize CSS 스타일 통일성 최고 보통 초기 개발 속도 느림 빠름 디자인 시스템 적합 다소 불편 마크업 구조 보존 낮음 높음 빠르게 결과물이 필요한 프로젝트 👉 Normalize CSS디자인 시스템 기반의 철저한 설계 👉 Reset CSS 📚 참고 자료 및 출처🔗 [DaleSeo 블로그] CSS Normalize vs Reset CSS 설명→ https://www.daleseo.com/html-css-reset-normalize/🎬 [디자인 베이스 YouTube] Reset &amp; Normalize CSS 차이 설명→ https://www.youtube.com/watch?v=dXgZK1dGspQ​https://velog.io/@nalsae/%EB%82%B4%EB%B3%B4%EC%A0%95CSS-reset-%EC%A4%84%EA%B9%8C-normalize-%EC%A4%84%EA%B9%8C reset이냐 normalize냐, 그것이 문제로다! 🤔 reset과 normalize, 둘 중에 뭘 써야 하지? velog.io ✍ 마무리하며Reset CSS와 Normalize CSS는 _브라우저 간 스타일 불일치 문제를 해결하기 위한 두 가지 방법_입니다. 프로젝트 성격, 디자인 방향, 팀의 스타일링 전략에 따라 적절히 선택해 사용해보세요.​​ " }, { "title": "️ [매일매일] 백엔드 기술 일기: 백엔드 서버 종료에도 ‘우아함’을! – Graceful Shutdown 완전 정리", "url": "/jekyll/update/2025/06/27/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-%EB%B0%B1%EC%97%94%EB%93%9C-%EC%84%9C%EB%B2%84-%EC%A2%85%EB%A3%8C%EC%97%90%EB%8F%84-%EC%9A%B0%EC%95%84%ED%95%A8-%EC%9D%84-Graceful-Shutdown-%EC%99%84%EC%A0%84-%EC%A0%95%EB%A6%AC.html", "categories": "jekyll, update", "tags": "", "date": "2025-06-27 13:07:20 +0900", "content": "서버가 종료될 때, 무조건 바로 꺼진다면 문제가 생길까요?정답은 “그렇다”입니다.바로 종료되는 서버는 진행 중인 작업이 강제 중단되며, 데이터 유실, 트랜잭션 꼬임, 사용자 경험 악화 등의 심각한 문제를 초래할 수 있어요.그래서 오늘은 서버 개발자라면 꼭 알아야 할 개념,Graceful Shutdown (우아한 종료)에 대해 정리해보겠습니다! ✅ Graceful Shutdown이란? “진행 중인 작업은 끝까지 처리하고 나서 안전하게 종료하는 방식” Graceful Shutdown은 서버가 종료될 때,새로운 요청은 더 이상 받지 않고,현재 처리 중인 요청만 모두 마무리한 뒤,각종 리소스(DB 커넥션, 파일, 메모리 등)를 정리하고 종료하는 방식입니다.​❌ 반면, Graceful하지 않은 종료는?현재 처리 중인 트랜잭션이 끊기거나 롤백되지 않음사용자 응답 중단 (API 호출 실패 등)파일 저장 미완, 로그 유실 등 🧨 SIGTERM vs SIGKILL서버 종료 시 운영체제에서 보내는 신호(signal) 도 함께 알아봐야 합니다. 시그널 의미 특징 SIGTERM 종료 요청 프로세스가 직접 처리 가능, 종료 전에 정리 작업 가능 SIGKILL 강제 종료 즉시 죽임, 정리 작업 수행 불가 Graceful Shutdown은 주로 SIGTERM을 감지해 동작합니다. 🌱 스프링(Spring) 환경에서의 Graceful ShutdownSpring Boot 2.3 이상부터는 기본적으로 우아한 종료 설정이 지원됩니다!​📌 설정 방법 (application.yml) server: shutdown: graceful spring: lifecycle: timeout-per-shutdown-phase: 20s # 최대 대기 시간 💡 동작 흐름서버가 SIGTERM을 받음새 요청 수신 중단기존 요청 완료까지 대기리소스 정리 (Thread, DB 등)종료 timeout-per-shutdown-phase는 요청이 너무 오래 걸리는 경우 자동으로 강제 종료되도록 합니다. (ex. 무한루프 등 방지) ⚠️ 주의할 점데드락, 무한 루프 같은 비정상 처리 로직이 있다면 timeout 내에도 종료되지 않을 수 있음ThreadPool이나 async 작업이 남아 있다면 정상 종료 안 될 수 있음외부 시스템(DB, Kafka 등)과 연결된 리소스도 명시적으로 close 해주는 습관이 필요함 📚 추천 자료https://effectivesquid.tistory.com/entry/JVM%EC%9D%98-%EC%A2%85%EB%A3%8C%EC%99%80-Graceful-Shutdown JVM의 종료와 Graceful Shutdown 개발자는 어플리케이션을 개발 할 때 많은 것들을 고려한다. 코드를 작성하고 나서는 비즈니스 로직이 정확한 결과를 산출해내는지 검증하기 위해 테스트 코드를 작성하기도 하며, 성능 테스트를 통해 시스템에 병목 지점은 없는지 등을 확인한다. 어플리케이션이 정상적으로 시작되고 실행이 지속되는지는 매우 중요하다. 하지만 어플리케이션이 정상적으로 종료되는지도 굉장히 중요하다. 이번 글을 통해서 JVM 플랫폼 위에서 실행되는 어플리케이션이 정상적으로 종료되기 위한 여러 내용들을 소개하려고한다. 프로세스 종료 먼저, 프로세스를 종료시키기 위해 프… effectivesquid.tistory.com https://velog.io/@byeongju/SpringBoot%EC%9D%98-Graceful-Shutdown SpringBoot Graceful-Shutdown 개념과 동작 원리 SpringBoot의 Graceful-Shutdown의 개념과 동작원리에 대해 알아보자 velog.io https://velog.io/@480/SIGKILL-vs-SIGTERM-%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%A2%85%EB%A3%8C-%EC%8B%A0%ED%98%B8 SIGKILL vs SIGTERM 리눅스 종료 신호 우리가 만든 서버 프로그램은 리눅스 서버의 한 프로세스로 동작 합니다.고로, 프로세스로 구동하는 모든 프로그램들, 예) 도커, nginx, node.js, Mysql 등의 종료에 관한 메커니즘을 이해 한다면, 장애 대비 개발을 할 수 있겠죠?그런데 요즘 아임웹은 배포에 velog.io https://velog.io/@dongvelop/Springboot-Graceful-Shutdown [Spring Boot] Graceful Shutdown(feat. 우아한 종료) 이제는 우아하게 종료시켜봐요 velog.io 📌 요약 정리 항목 설명 목적 서버 종료 시 요청 누락, 데이터 손실 방지 동작 방식 새 요청 거부 → 기존 요청 처리 → 리소스 해제 → 종료 주요 설정 server.shutdown=graceful, timeout-per-shutdown-phase=20s 사용하는 시그널 SIGTERM (우아한 종료), SIGKILL (즉시 종료) 주의사항 데드락, 무한 루프, 비동기 처리 등 종료 방해 요소 고려 💡 서버는 “죽을 때”도 품격 있게!Graceful Shutdown은 단순한 기능이 아니라,서비스 신뢰도와 데이터 무결성을 지키기 위한 필수 설계입니다. 🔖 태그: #백엔드 #Spring #GracefulShutdown #SIGTERM #서버종료 #매일매일​ " }, { "title": "[매일매일]프론트엔드 기술 일기: 타입 단언(Type Assertion) 쉽게 정리하기", "url": "/jekyll/update/2025/06/27/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-%ED%83%80%EC%9E%85-%EB%8B%A8%EC%96%B8-Type-Assertion-%EC%89%BD%EA%B2%8C-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0.html", "categories": "jekyll, update", "tags": "", "date": "2025-06-27 12:55:19 +0900", "content": "프론트엔드 개발을 하다 보면 타입스크립트에서 as 키워드를 종종 만나게 됩니다. 이게 바로 타입 단언(Type Assertion) 입니다.오늘은 이 개념이 언제, 왜 필요한지, 그리고 어떻게 안전하게 써야 하는지 차근차근 정리해보겠습니다. ✅ 타입 단언이란?타입 단언은 “이 값의 타입을 내가 더 잘 알고 있으니, 컴파일러야 믿고 따라와!” 라는 뜻입니다.타입스크립트는 기본적으로 자동 타입 추론을 해주지만, 때때로 정확히 어떤 타입인지 컴파일러가 추론하지 못하는 경우가 있습니다.이럴 때 개발자가 직접 타입을 알려주는 방법이 바로 타입 단언입니다. const element = document.getElementById(“myElement”) as HTMLDivElement; element.style.backgroundColor = “blue”; // 오류 없이 사용 가능 getElementById는 HTMLElement null을 반환하지만, 우리는 HTMLDivElement라고 확신하므로 as를 사용합니다. 💡 언제 사용하나요?DOM 조작처럼 구체적인 타입을 확신할 때외부 라이브러리의 반환값이 타입스크립트에서 애매하게 추론될 때초기값이 null일 수 있지만, 이후 반드시 값이 들어오는 경우 ⚠️ 주의할 점은?타입 단언은 타입스크립트의 타입 검사 우회 수단이기 때문에, 실제 값이 단언한 타입과 다르면 런타임 오류가 발생할 수 있습니다.즉, “컴파일은 통과하지만, 실제로 실행하면 터질 수 있음” 을 의미하므로 반드시 조심해서 사용해야 합니다. 🔐 더 안전하게 쓰는 방법1. 타입 단언보다 타입 내로잉(Narrowing) function printLength(value: string | string[]) { if (Array.isArray(value)) { console.log(value.length); // 안전하게 배열 처리 } else { console.log(value.length); // 문자열 처리 } } 조건문 등을 통해 타입을 좁히면 as 없이도 안전하게 코딩 가능! 타입 가드(Type Guard) 사용 function isFish(pet: Fish | Bird): pet is Fish { return (pet as Fish).swim !== undefined; } if (isFish(pet)) { pet.swim(); // 이제 pet은 Fish! } 타입을 확인해주는 함수(pet is Fish)를 통해 보다 명확한 분기 가능. 부분 단언으로 위험 최소화 const el = document.getElementById(“myElement”); if (el) { (el as HTMLDivElement).style.backgroundColor = “blue”; } 전체 변수보단 속성 단위로 필요한 부분에만 단언! 📚 더 공부하고 싶다면?https://joshua1988.github.io/ts/guide/type-assertion.html#%ED%83%80%EC%9E%85-%EB%8B%A8%EC%96%B8-type-assertion 타입 단언 | 타입스크립트 핸드북 타입 단언(Type Assertion) 타입 단언은 개발자가 해당 타입에 대해 확신이 있을 때 사용하는 타입 지정 방식입니다. 다른 언어의 타입 캐스팅과 비슷한 개념이며 타입스크립트를 컴파일 할 때 특별히 타입을 체크하지 않고, 데이터의 구조도 신경쓰지 않습니다. # 타입 단언 기본 - as 타입 단언은 기본적으로 as 키워드를 이용해서 정의할 수 있습니다. 아래와 같은 코드가 있다고 합시다. const name : string = ‘Capt’ ; 이 코드는 타입 표기 방식을 이용해 name 이라는 변수의 타입은 string 이… joshua1988.github.io https://yceffort.kr/2019/08/20/typescript-type-assertion 타입스크립트 타입 단언 https://yceffort.kr yceffort.kr https://lily-im.tistory.com/116 [Typescript] 타입의 종류 - 원시타입 / 객체타입 / 기타 목차 0. 들어가며 1. 알 고쓰자 TypeScript : 왜 타스인가 ? 2. 타입의 종류 1. 원시타입 string, number, BigInt, boolean, null, undefined, symbol 1 ) string let str: string; str = ‘123’; str = 123; // Error 2) number let num: number; num = 123; num = 123.456; num = ‘123’; // Error 3) BigInt 원시 값이 안정적으로 나타낼 수 있는 최대치인 2^53 - 1보다 … lily-im.tistory.com 🧾 마무리 요약 항목 설명 무엇인가요? 타입스크립트가 추론 못할 때, 직접 타입을 지정하는 방법 어떻게 쓰나요? as 타입명 을 사용 언제 써야 하나요? DOM 조작, 외부 API 등 타입 확신이 있을 때 주의할 점 컴파일러 검사를 우회하므로 실제 타입 불일치 시 런타임 에러 가능 대안 타입 내로잉, 타입 가드 활용 우선 고려 📝 정확히 알고 쓰면 매우 강력한 도구!그러나 남용은 금물입니다.타입스크립트의 장점을 제대로 누리기 위해선, 추론 → 가드 → 단언 순으로 적용해보세요! 🔖 태그: #타입스크립트 #프론트엔드 #TypeAssertion #매일매일 " }, { "title": "[매일매일] 프론트엔드 기술 일기: JavaScript의 this, 상황에 따라 달라지는 바인딩 정리", "url": "/jekyll/update/2025/06/26/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-JavaScript%EC%9D%98-this-%EC%83%81%ED%99%A9%EC%97%90-%EB%94%B0%EB%9D%BC-%EB%8B%AC%EB%9D%BC%EC%A7%80%EB%8A%94-%EB%B0%94%EC%9D%B8%EB%94%A9-%EC%A0%95%EB%A6%AC.html", "categories": "jekyll, update", "tags": "", "date": "2025-06-26 14:57:44 +0900", "content": "자바스크립트에서 this는 고정된 값이 아니라 함수 호출 방식에 따라 동적으로 결정됩니다.오늘은 this가 바인딩되는 6가지 대표적인 상황을 예제와 함께 정리해봤습니다. 1️⃣ 전역 호출 (Global Context) function globalFunc() { console.log(this); } globalFunc(); 브라우저 환경: windowNode.js 환경: global 전역에서 선언한 함수는 전역 객체에 바인딩됩니다. 2️⃣ 메서드 호출 (Object Method) const obj = { name: “Alice”, greet: function () { console.log(this.name); }, }; obj.greet(); // “Alice” this는 호출된 객체(obj) 를 가리킵니다.주의: const greet = obj.greet; greet(); 이렇게 따로 빼서 호출하면 this는 달라질 수 있음. 3️⃣ 생성자 함수 &amp; 클래스 (Constructor &amp; Class) function Person(name) { this.name = name; } const person = new Person(“Alice”); console.log(person.name); // “Alice” this는 새로 생성된 인스턴스를 참조합니다.클래스도 같은 동작을 합니다. class User { constructor(name) { this.name = name; } } const user = new User(“Bob”); 4️⃣ 명시적 바인딩 (call, apply, bind) function greet() { console.log(this.name); } const user = { name: “Alice” }; greet.call(user); // “Alice” greet.apply(user); // “Alice” const boundGreet = greet.bind(user); boundGreet(); // “Alice” call()과 apply()는 즉시 호출bind()는 새로운 함수 반환 5️⃣ 화살표 함수 (Arrow Function) const obj = { name: “Alice”, greet: () =&gt; console.log(this.name), }; obj.greet(); // undefined 화살표 함수는 자신의 this를 갖지 않고, 상위 스코프의 this를 그대로 사용합니다.일반적으로 전역 this 또는 외부 함수의 this를 가리킴 function Timer() { this.seconds = 0; setInterval(() =&gt; { this.seconds++; console.log(this.seconds); }, 1000); } 6️⃣ DOM 이벤트 핸들러 function Timer() { this.seconds = 0; setInterval(() =&gt; { this.seconds++; console.log(this.seconds); }, 1000); } 일반 함수: 이벤트를 발생시킨 DOM 요소화살표 함수: 상위 스코프의 this 📌 요약 비교표 호출 방식 this가 참조하는 대상 전역 함수 호출 window (브라우저) / global (Node.js) 객체 메서드 호출 해당 객체 생성자 함수 호출 새로 생성된 인스턴스 call/apply/bind 명시적으로 지정한 객체 화살표 함수 상위 스코프의 this DOM 이벤트 핸들러 일반 함수: 이벤트 대상 / 화살표: 상위 this 📚 참고 자료https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this this - JavaScript | MDN JavaScript에서 함수의 this 키워드는 다른 언어와 조금 다르게 동작합니다. 또한 엄격 모드와 비엄격 모드에서도 일부 차이가 있습니다. developer.mozilla.org ​ " }, { "title": "[매일매일] 백엔드 기술 일기: CQRS 패턴이란? — 명령과 조회를 분리해보자!", "url": "/jekyll/update/2025/06/26/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-CQRS-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80-%EB%AA%85%EB%A0%B9%EA%B3%BC-%EC%A1%B0%ED%9A%8C%EB%A5%BC-%EB%B6%84%EB%A6%AC%ED%95%B4%EB%B3%B4%EC%9E%90.html", "categories": "jekyll, update", "tags": "", "date": "2025-06-26 14:33:41 +0900", "content": "오늘은 백엔드 설계 패턴 중 하나인 CQRS(Command Query Responsibility Segregation) 패턴에 대해 공부해봤습니다.이 패턴은 복잡한 시스템을 보다 명확하게 분리하고 유지보수를 용이하게 만드는 데 큰 도움을 줍니다. 🧠 CQRS 패턴이란?CQRS는 명령(Command) 과 조회(Query) 를 책임(Responsibility) 별로 분리(Segregation) 하는 설계 패턴입니다.​명령(Command) = 시스템의 상태를 변경하는 작업예: 주문 생성, 결제 처리, 정보 수정​조회(Query) = 시스템의 상태를 읽는 작업예: 주문 내역 조회, 사용자 정보 보기​📌 즉, 한 개의 모델이 모든 책임을 지는 대신,변경은 Order 같은 명령 모델조회는 OrderData 같은 조회 모델로 역할을 나눠서 구현합니다. 🛠️ 예시로 보는 CQRS 💡 Order 리소스를 관리하는 경우 기존 방식 (단일 모델) Order order = orderRepository.findById(id); order.cancel(); order.getCreatedAt(); CQRS 방식Command 모델 → Order: 주문 생성, 수정, 취소 등 변경 처리Query 모델 → OrderData: 주문일자, 상태 등 조회 처리 ✅ 장점 정리1. 책임이 분리되어 코드가 명확해짐→ 각 모델이 하나의 역할에만 집중하므로 유지보수성 향상​2. 성능 최적화에 유리→ 명령에는 트랜잭션이 강한 RDB,→ 조회에는 빠른 응답의 NoSQL 또는 캐시 사용 가능​3. 다양한 기술 혼용 가능→ 명령에는 JPA, 조회에는 MyBatis 등 각각에 최적화된 도구 선택 가능 ⚠️ 단점 정리구현이 복잡해질 수 있음인프라 구성 및 데이터 동기화(예: Kafka, Event Store 등) 필요작은 프로젝트에는 오히려 과도한 설계일 수 있음 📚 추천 자료 모음https://www.youtube.com/watch?v=xf0kXMTFJm8 https://www.youtube.com/watch?v=H1IF3BUeFb8 https://www.youtube.com/watch?v=fg5xbs59Lro https://www.youtube.com/watch?v=704qQs6KoUk https://medium.com/coupang-engineering/%EB%8C%80%EC%9A%A9%EB%9F%89-%ED%8A%B8%EB%9E%98%ED%94%BD-%EC%B2%98%EB%A6%AC%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%BF%A0%ED%8C%A1%EC%9D%98-%EB%B0%B1%EC%97%94%EB%93%9C-%EC%A0%84%EB%9E%B5-184f7fdb1367 대용량 트래픽 처리를 위한 쿠팡의 백엔드 전략 마이크로서비스로 고객에게 데이터 서빙하기: 고가용성, 고처리량, 그리고 지연시간 최소화 — Part 1 medium.com https://docs.aws.amazon.com/ko_kr/prescriptive-guidance/latest/modernization-data-persistence/cqrs-pattern.html CQRS 패턴 - AWS 권장 가이드 CQRS(명령 쿼리 책임 분리) 패턴은 데이터 변형 또는 시스템의 명령 부분을 쿼리 부분과 분리합니다. 처리량, 지연 시간 또는 일관성에 대한 요구 사항이 서로 다른 경우 CQRS 패턴을 사용하여 업데이트와 쿼리를 분리할 수 있습니다. CQRS 패턴은 다음 다이어그램과 같이 애플리케이션을 명령 측과 쿼리 측의 두 부분으로 분할합니다. 명령측은 create , update , delete 요청을 처리합니다. 쿼리 측에서는 읽기 전용 복제본을 사용하여 docs.aws.amazon.com ✍️ 마무리 메모처음에는 헷갈릴 수 있지만, “조회는 읽기만! 변경은 명확하게!” 라는 철학을 이해하면 CQRS는 훌륭한 아키텍처 전략이 됩니다.​ " }, { "title": "[매일매일] CI/CD 파이프라인이란? – 지속적인 개발 흐름의 핵심", "url": "/jekyll/update/2025/06/25/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-CI-CD-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8%EC%9D%B4%EB%9E%80-%EC%A7%80%EC%86%8D%EC%A0%81%EC%9D%B8-%EA%B0%9C%EB%B0%9C-%ED%9D%90%EB%A6%84%EC%9D%98-%ED%95%B5%EC%8B%AC.html", "categories": "jekyll, update", "tags": "", "date": "2025-06-25 19:24:35 +0900", "content": "개발한 코드를 자동으로 빌드하고 테스트하고, 문제 없이 잘 되면 배포까지 쭉!이게 바로 우리가 말하는 CI/CD 파이프라인입니다.이번 글에서는 CI(지속적 통합), CD(지속적 전달/배포) 의 개념부터 실제 도구까지 핵심만 정리해봅니다. ✅ CI (Continuous Integration) – 코드는 매일매일 합쳐야 맛이지! “작은 변경을 자주! 그리고 빠르게 확인하자” CI는 개발자가 작업한 코드를 공통 저장소(Repository) 에 자주 병합(Merge)하면서,매 병합마다 자동으로 빌드 + 테스트 를 수행하는 방식입니다. ✅ 왜 중요한가요?실시간으로 버그를 빠르게 찾고통합 시 충돌을 최소화하며코드 퀄리티를 유지할 수 있습니다​🔧 예시 도구GitHub ActionsJenkinsTravis CIGitLab CI ✅ CD – 이름이 같아도 두 가지 의미?CD는 두 가지로 나뉩니다.1. Continuous Delivery (지속적 전달) 자동 배포 바로 직전까지, 운영자가 수동 승인만 하면 배포됨. CI → 테스트 통과 → 빌드 결과(artifact) 생성 → 배포 대기 운영자가 직접 눌러야 배포되므로 “신중한 팀”에 적합합니다. Continuous Deployment (지속적 배포) CI 이후의 흐름이 전부 자동입니다. CI → 테스트 통과 → 자동 배포까지 완료! 변경사항이 문제 없다면 바로 운영에 반영되는 구조입니다.빠른 서비스 출시를 원한다면 이 방식이 강력합니다. 🗂️ 빌드 아티팩트(산출물) 저장소는 어디에?CI/CD에서 빌드된 파일(JAR, Docker 이미지 등)은 중간에 보관됩니다.다음과 같은 저장소를 활용합니다:AWS S3DockerHub / Docker RegistryNexus Repository Manager 📈 전체 흐름 예시 graph LR A[개발자가 코드 Push] –&gt; B[CI 서버에서 빌드 &amp; 테스트] B –&gt; C[테스트 통과 여부 확인] C –&gt;|통과| D[배포 준비 또는 자동 배포] C –&gt;|실패| E[알림 → 개발자 수정] 🚀 CI/CD 도구 모음 도구 특징 Jenkins 가장 널리 쓰이는 오픈소스 자동화 서버 GitHub Actions GitHub 저장소와 밀접한 연동, 간편한 설정 GitLab CI/CD GitLab에 내장된 강력한 파이프라인 기능 Travis CI 간단한 YAML 기반, 빠른 셋업 TeamCity JetBrains 제공, 강력한 UI와 통계 기능 📝 한 줄 정리 CI/CD 파이프라인이란, 코드 변경 → 테스트 → 빌드 → 배포까지의 과정을 자동화한 일련의 흐름입니다. 🧭 CI/CD 전체 흐름도 (실무 예시) graph TD A[개발자가 Git에 Push 또는 PR 생성] –&gt; B[CI 트리거 - 빌드 서버 작동] B –&gt; C[의존성 설치 &amp; 코드 빌드] C –&gt; D[테스트 실행 (단위/통합)] D –&gt; E{테스트 결과 성공?} E –&gt;|Yes| F[배포용 아티팩트 생성 (JAR/Docker)] F –&gt; G{배포 방식} G –&gt;|CD: 자동 배포| H[운영 서버에 자동 배포] G –&gt;|CD: 수동 승인| I[운영자 승인 후 배포] E –&gt;|No| J[Slack/메일 등으로 알림 후 종료] 🛠️ GitHub Actions CI/CD 예제 (Spring Boot + Docker)📄 .github/workflows/ci-cd.yml name: CI/CD Pipeline on: push: branches: [ “main” ] pull_request: branches: [ “main” ] jobs: build-and-deploy: runs-on: ubuntu-latest steps: # 1. 소스코드 체크아웃 - name: Checkout source code uses: actions/checkout@v3 # 2. JDK 설치 - name: Set up JDK 17 uses: actions/setup-java@v3 with: java-version: '17' distribution: 'temurin' # 3. Gradle 빌드 - name: Build with Gradle run: ./gradlew clean build # 4. Docker 이미지 빌드 및 푸시 - name: Docker Build &amp; Push uses: docker/build-push-action@v4 with: context: . push: true tags: your-dockerhub-username/your-app-name:latest # 5. 서버로 SSH 배포 (옵션) - name: Deploy via SSH uses: appleboy/ssh-action@v1.0.0 with: host: $ username: $ key: $ script: | docker pull your-dockerhub-username/your-app-name:latest docker stop your-container || true docker rm your-container || true docker run -d --name your-container -p 8080:8080 your-dockerhub-username/your-app-name:latest 🔐 필요한 GitHub Secrets 이름 설명 SERVER_HOST 배포 대상 서버 IP or 도메인 SERVER_USER SSH 접속용 사용자 이름 SSH_PRIVATE_KEY SSH 개인 키 DOCKERHUB_TOKEN DockerHub 인증용 토큰 (필요 시) ✍️ 커스터마이징 팁Spring Boot 프로젝트면 ./gradlew build 이후 생성되는 build/libs/*.jar 파일을 직접 배포하거나,Docker 환경이라면 컨테이너 기반 배포로 구성합니다.위 예시는 main 브랜치 push 시 자동 실행되며, 배포 자동화까지 연계된 예입니다. 📚 참고 자료https://www.youtube.com/watch?v=sIPU_VkrguI https://www.youtube.com/watch?v=SKILL1pT6f4 https://www.jetbrains.com/ko-kr/teamcity/ci-cd-guide/continuous-integration-vs-delivery-vs-deployment/# 지속적 통합 vs 전달 vs 배포 | TeamCity 가이드 포괄적인 TeamCity 가이드를 통해 CI(지속적 통합), 지속적 전달 및 지속적 배포의 차이점을 알아보세요. www.jetbrains.com https://www.redhat.com/ko/topics/devops/what-is-ci-cd CI/CD: 지속적 통합과 배포의 핵심 개념과 차이점 이해하기 CI/CD(지속적 통합/지속적 배포)는 애플리케이션 개발부터 배포까지 자동화된 프로세스로 효율성을 향상하는 방법입니다. CI/CD의 개념, 주요 툴, 구축 방법을 알아보세요 www.redhat.com ✍️ 김기성 – 오늘도 코드는 자동으로 흘러갑니다.기왕이면 안정적이고 빠르게! CI/CD는 더 이상 선택이 아니라 필수입니다.#백엔드 #CI #CD #지속적통합 #자동배포 #Jenkins #GitHubActions #매일매일 " }, { "title": "[매일매일] 프론트엔드 기술일기: preconnect, preload, prefetch – 리소스 로딩 성능 최적화 3종 세트", "url": "/jekyll/update/2025/06/25/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0%EC%9D%BC%EA%B8%B0-preconnect-preload-prefetch-%EB%A6%AC%EC%86%8C%EC%8A%A4-%EB%A1%9C%EB%94%A9-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-3%EC%A2%85-%EC%84%B8%ED%8A%B8.html", "categories": "jekyll, update", "tags": "", "date": "2025-06-25 19:11:59 +0900", "content": "프론트엔드 성능 최적화를 고민할 때 꼭 알아야 할 태그 속성이 있습니다.바로 preconnect, preload, prefetch입니다.이 세 가지는 리소스 “언제, 어떻게 미리 불러올지” 결정하는 데 중요한 역할을 합니다.하나하나 예제와 함께 정리해봅니다. ✅ preconnect: 연결만 미리 열어두기 외부 리소스 도메인에 대해 네트워크 연결(DNS, TCP, TLS) 을 먼저 열어줍니다. 📌 사용 예시 🔍 언제 쓰나?Google Fonts, 외부 CDN, 외부 API 요청이 자주 발생하는 경우실제 리소스 로딩 전에 대기 시간을 줄여 최초 요청 속도 개선 ✅ preload​: 바로 쓸 리소스 미리 받아두기 곧 사용할 리소스를 브라우저가 우선적으로 다운로드 하게 합니다. 📌 사용 예시 🔍 언제 쓰나?웹폰트 (FOUT 현상 방지)영상, 이미지, JS 등 렌더링에 즉시 필요한 리소스 as 속성을 꼭 지정해야 리소스 유형을 명확히 알려줄 수 있어요. ✅ prefetch: 다음에 쓸 리소스 느긋하게 받아두기 곧 필요할 수도 있는 리소스를 여유 있을 때 백그라운드로 로드 📌 사용 예시 🔍 언제 쓰나?사용자가 다음 페이지로 이동할 가능성이 높은 경우싱글 페이지 애플리케이션(SPA) 에서 페이지 전환이 부드럽게 되도록 할 때 📝 요약 비교표 속성 역할 리소스 로딩 시점 우선순위 preconnect 네트워크 연결 미리 생성 리소스 요청 전에 🔼 높음 preload 지금 바로 쓸 리소스 미리 로드 초기 렌더링 전 🔼 높음 prefetch 나중에 쓸 리소스 미리 로드 백그라운드 여유 시간에 🔽 낮음 📚 참고 자료https://web.dev/learn/performance/resource-hints?hl=ko 리소스 힌트로 브라우저 지원  |  web.dev 리소스 힌트는 HTML에서 사용할 수 있는 기능 모음으로, 브라우저가 리소스를 더 일찍 로드하거나 리소스 우선순위가 더 높을 수 있도록 지원할 수 있습니다. 이 모듈에서는 페이지를 더 빠르게 로드하는 데 도움이 되는 몇 가지 리소스 힌트를 다룹니다. web.dev https://www.youtube.com/watch?v=PLYIrkT4OCg ✍️ 김기성 – 프론트 성능 최적화도 결국 디테일 싸움입니다.오늘은 하나로도 사용자 경험을 바꿀 수 있다는 걸 배웠습니다.​#프론트엔드 #HTML #성능최적화 #preconnect #preload #prefetch #매일매일 " }, { "title": "✅ [매일매일]백엔드 기술 일기: 코드 커버리지(Code Coverage) 완전 정리", "url": "/jekyll/update/2025/06/24/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-%EC%BD%94%EB%93%9C-%EC%BB%A4%EB%B2%84%EB%A6%AC%EC%A7%80-Code-Coverage-%EC%99%84%EC%A0%84-%EC%A0%95%EB%A6%AC.html", "categories": "jekyll, update", "tags": "", "date": "2025-06-24 16:40:51 +0900", "content": "테스트 코드를 작성하는 목적은 “실제 코드가 잘 작동하는지 검증”하기 위함이죠.그렇다면, “얼마나 잘 테스트하고 있을까?”를 수치로 보여주는 지표가 있다면?그게 바로 오늘의 주제, 코드 커버리지(Code Coverage) 입니다! 🧪 코드 커버리지란? “테스트가 실제 코드를 얼마나 실행시켰는지 나타내는 비율” 단순히 테스트를 작성하는 것만으로 끝나지 않고,어떤 코드가 테스트되었고, 어떤 코드가 빠졌는지를 수치로 파악할 수 있습니다. 📊 커버리지 측정 기준 3가지 구분 설명 예시 구문 커버리지 (Statement Coverage) 코드 라인들이 테스트에서 실행되었는지 전체 10줄 중 8줄이 실행 → 80% 결정 커버리지 (Decision/Branch Coverage) if, switch 등의 분기 조건이 모두 테스트되었는지 true, false 분기 모두 실행 조건 커버리지 (Condition Coverage) 조건식 내부의 각 서브 조건이 true/false를 모두 가졌는지 a &gt; 0, b &gt; 0 각각의 결과 테스트 🔍 예제 코드로 이해해보기 public void productionCode(int a, int b) { if (a &gt; 0 &amp;&amp; b &gt; 0) { // … } } 테스트 케이스 의미 productionCode(1, 1) 둘 다 true → 결정, 조건 커버리지 일부 만족 productionCode(0, 1) a 조건 false 확인 productionCode(1, 0) b 조건 false 확인 ✔️ 조건 커버리지를 만족하려면→ a &gt; 0, b &gt; 0 각각이 true/false 되는 케이스 필요​✔️ 결정 커버리지를 만족하려면→ 전체 조건식 결과가 true/false 모두 실행되어야 함 ⚠️ 커버리지가 높으면 무조건 좋은 걸까? 🤔 NO!커버리지는 “얼마나 테스트를 거쳤는지”는 알려주지만”테스트가 제대로 작성되었는지”는 말해주지 않습니다. ❌ 커버리지는 90%인데도 버그가 생길 수 있음​❌ 의미 없는 테스트가 코드만 실행해도 커버리지만 올라감​❌ 현실적으로 모든 예외 상황을 커버하기 어려움​그래서 커버리지는 보조 지표로 참고하고,의미 있는 테스트 케이스 작성이 핵심입니다. 🛠️ 커버리지 측정 도구 예시Java: JaCoCo, IntelliJ Coverage, CoberturaJavaScript/TypeScript: Jest, Istanbul, nycPython: Coverage.py 📚 추가 학습 자료https://www.youtube.com/watch?v=jdlBu2vFv58 https://tecoble.techcourse.co.kr/post/2020-10-24-code-coverage/ 코드 커버리지(Code Coverage)가 뭔가요? 팀 프로젝트 요구 사항 우아한테크코스에서는 레벨 3,4 과정에서 팀 프로젝트를 진행하였다. 레벨 3에서 서비스를 구현했다면, 레벨… tecoble.techcourse.co.kr https://yozm.wishket.com/magazine/detail/2471/ 개발자여, 테스트 커버리지에 집착 말자 | 요즘IT 글을 시작하기 앞서, ‘테스트’라는 낱말이 매우 보편적으로 쓰이기 때문에 이 글에서 말하는 테스트가 무엇인지 정의할 필요가 있다. 이 글에서 ‘테스트’는 개발자가 코드로 작성하고 코드를 실행하여 자동으로 테스트를 수행하는 것을 뜻한다. 요즘은 테스트 코드를 작성하는 것 자체가 논쟁 대상이 되지 않을 정도로 많은 개발자들(조직)이 테스트에 관심을 가지고 테스트를 작성한다. 개발자가 만든 테스트 코드를 측정하는 방법으로 보통 테스트(코드) 커버리지를 사용한다. 커버리지 지표는 테스트 코드가 코드 베이스를 얼마나 실행하는지 백분율로 나타… yozm.wishket.com ​ " }, { "title": "[매일매일] 프론트엔드 기술 일기: 쌓임 맥락(Stacking Context) 개념 정리", "url": "/jekyll/update/2025/06/24/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-%EC%8C%93%EC%9E%84-%EB%A7%A5%EB%9D%BD-Stacking-Context-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC.html", "categories": "jekyll, update", "tags": "", "date": "2025-06-24 16:29:40 +0900", "content": "프론트엔드를 하다 보면 z-index를 아무리 높여도 요소가 안 올라오는 경험, 다들 한 번쯤 해보셨을 거예요.그 이유는 바로 쌓임 맥락(Stacking Context) 때문입니다. 🌀 쌓임 맥락이란?​HTML/CSS에서 요소들이 화면에 표시될 때, 2D가 아닌 가상의 3차원 공간(z축) 위에 배치됩니다.이때 요소들의 위계 관계를 쌓임 맥락이라는 개념으로 관리합니다. 📌 쉽게 말해:❝서로 다른 집에 사는 친구들은 서로의 방 구조를 모릅니다❞→ 쌓임 맥락이 다르면 서로의 z-index를 비교할 수 없습니다. 🧭 기본 쌓임 규칙HTML은 기본적으로 DOM 순서대로 요소를 쌓습니다.position 속성 + z-index를 활용하면 쌓임 순서를 조정할 수 있습니다.그러나 쌓임 맥락이 생성되면, 그 안의 요소들은 독립적으로 쌓입니다. 🏗️ 쌓임 맥락이 생성되는 조건 조건 설명 position: relative/absolute + z-index z-index가 auto가 아닌 경우 position: fixed 또는 sticky 항상 새로운 쌓임 맥락 생성 opacity &lt; 1 투명도가 적용되면 쌓임 맥락 생성 transform, filter, backdrop-filter 시각적 변형이 적용되면 생성 display: flex/grid + z-index 해당 조합에서도 생성 가능 🔍 예시 코드 A 요소 (z-index: 1) A-1 요소 (z-index: 999) B 요소 (z-index: 2) 🧠 쌓이는 순서:B 요소 (z-index: 2) ← 최상위 쌓임 맥락에서 가장 큼A-1 요소 (z-index: 999) ← A 요소 내부 쌓임 맥락의 최상단A 요소 (z-index: 1)❗️주의: A-1의 z-index가 아무리 커도, B 요소보다 위에 올라갈 수 없습니다.왜냐하면 A 요소가 만든 쌓임 맥락 안에 있기 때문입니다. 🧩 자주 하는 실수z-index: 9999를 줬는데도 안 올라온다?👉 쌓임 맥락이 달라서입니다!​overlay 모달이 버튼 뒤로 간다?👉 부모 요소에 transform, opacity, z-index 등이 있는지 확인하세요. 📚 추가 학습 자료https://www.youtube.com/watch?v=ln9vfw-JAr8 https://developer.mozilla.org/ko/docs/Web/CSS/CSS_positioned_layout/Stacking_context 쌓임 맥락 - CSS: Cascading Style Sheets | MDN 쌓임 맥락(stacking context)은 가상의 Z축을 사용한 HTML 요소의 3차원 개념화입니다. Z축은 사용자 기준이며, 사용자는 뷰포트 혹은 웹페이지를 바라보고 있을 것으로 가정합니다. 각각의 HTML 요소는 자신의 속성에 따른 우선순위를 사용해 3차원 공간을 차지합니다. developer.mozilla.org ✍️ 마무리 정리 z-index는 비교할 수 있는 “범위”가 같을 때만 의미가 있다.쌓임 맥락이 다르면 z-index 비교는 무의미하다. ​ " }, { "title": "☕ [매일매일]백엔드 기술일기: 의존성 주입(Dependency Injection)이란? – 유연하고 확장 가능한 객체 설계의 핵심", "url": "/jekyll/update/2025/06/23/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0%EC%9D%BC%EA%B8%B0-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85-Dependency-Injection-%EC%9D%B4%EB%9E%80-%EC%9C%A0%EC%97%B0%ED%95%98%EA%B3%A0-%ED%99%95%EC%9E%A5-%EA%B0%80%EB%8A%A5%ED%95%9C-%EA%B0%9D%EC%B2%B4-%EC%84%A4%EA%B3%84%EC%9D%98-%ED%95%B5%EC%8B%AC.html", "categories": "jekyll, update", "tags": "", "date": "2025-06-23 18:44:06 +0900", "content": "“객체를 생성할 때 직접 만들지 않고, 누가 대신 만들어 준다면?”바로 의존성 주입(Dependency Injection, DI)의 시작입니다. https://www.elancer.co.kr/blog/detail/158 ✅ 의존성(Dependency)이란?예를 들어, A 객체가 어떤 작업을 수행하기 위해 B 객체를 필요로 한다면, 우리는 “A는 B에 의존한다”고 표현합니다.이때 B를 직접 생성하거나 관리하게 되면, A와 B는 강하게 결합되며 유연성이 떨어지게 됩니다. 🔄 의존성 주입이란?의존성 주입(DI)은 외부 객체(C)가 필요한 의존 객체(B)를 생성하고, 이를 사용 객체(A)에게 주입해주는 방식입니다. 기존 방식: A 객체 → B 객체 직접 생성 및 사용 (강한 결합) DI 방식: C 객체 → B 객체 생성 → A 객체에게 전달 (느슨한 결합) 이처럼 생성 책임을 외부로 위임하면, A는 B의 구체적인 구현에 의존하지 않고도 동작하게 됩니다. 💡 의존성 주입의 장점 장점 설명 1️⃣ 낮은 결합도 객체 간 직접적인 의존 관계를 제거하여 유지보수 쉬움 2️⃣ 테스트 용이 테스트 시 모의 객체(mock)를 쉽게 주입 가능 3️⃣ 코드 재사용성 ↑ 구현체만 바꾸면 다양한 상황 대응 가능 4️⃣ 변경에 강한 구조 구현 변경 시 호출부 수정 필요 없음 🧪 주입 방식 – 언제 무엇을 써야 할까? 주입 방식 설명 적절한 상황 생성자 주입 생성자 파라미터로 의존성 전달 불변 의존성, 초기화 시점 명확하게 Setter 주입 set 메서드로 전달 선택적 의존, 초기화 이후 설정 가능 메서드 주입 특정 메서드 내부에서 일시적으로 전달 매번 다른 인스턴스 필요할 때 🔸 생성자 주입이 가장 안정적이며, 필수 의존성에 적합합니다.🔸 Setter나 메서드 주입은 조건부/선택적 의존성에 활용됩니다. 📚 예시 코드 – Spring 기준 생성자 주입 @Component public class OrderService { private final PaymentService paymentService; @Autowired // 생략 가능 public OrderService(PaymentService paymentService) { this.paymentService = paymentService; } } 이렇게 작성하면 PaymentService는 외부에서 자동으로 주입되며, OrderService는 구현체를 몰라도 동작합니다.​https://jeongkyun-it.tistory.com/172 [Spring] 의존성 주입(Dependency Injection)이란? (개념/ 예제/ 총 정리) 서론 이번글에서는 스프링을 이용한 의존성 주입에 대해서 알아보려한다. 의존성 주입(DI)은 크게 4가지 방법이 있다. 1. 생성자 주입 2. 수정자 주입(setter 주입) 3. 필드 주입 4. 일반 메서드 주입 위와 같이 4가지 방법이 있는데, 네가지 중 어떤 방식이 효율적이고 실제 실무에서 어떻게 쓰이는지 간략히 정리해보려한다. 의존성 주입(Dependency Injection)이란? Sprng Framework의 3가지 핵심 프로그래밍 중 하나인 의존성 주입(DI)는 외부에서 두 객체 간의 관계를 결정해주는 디자인 패턴으로 인… jeongkyun-it.tistory.com 🧭 마무리 정리의존성 주입은 객체 간 결합도를 낮춰주는 설계 방식입니다.​테스트와 유지보수에 유리하며, Spring, NestJS, Angular 등 많은 프레임워크에서 기본 지원합니다.​어떤 주입 방식을 쓸지는 상황에 따라 달라지며, 팀 내 컨벤션에 맞추는 것이 중요합니다. 🔗 추천 참고자료https://www.youtube.com/watch?v=8lp_nHicYd4 https://www.youtube.com/watch?v=BO7QFUnVdjc https://tecoble.techcourse.co.kr/post/2021-04-27-dependency-injection/ 의존관계 주입(Dependency Injection) 쉽게 이해하기 이번 글에서는 DI(의존성 주입, 의존관계 주입)의 개념을 설명한다. DI란 용어가 주는 위압감과 부담감 때문에 이해를 미뤄뒀거나, 처음 접하는 분들이 쉽게 이해할 수 있도록 쉽게 설명하고자 한다. DI 란 무엇인가 DI는 Dependency… tecoble.techcourse.co.kr ​​ " }, { "title": "[매일매일] 프론트엔드 기술 스택: Next.js Server Action 완전 이해하기 – 백엔드 API 없이 DB 직접 조작하기", "url": "/jekyll/update/2025/06/23/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%8A%A4%ED%83%9D-Next-js-Server-Action-%EC%99%84%EC%A0%84-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EB%B0%B1%EC%97%94%EB%93%9C-API-%EC%97%86%EC%9D%B4-DB-%EC%A7%81%EC%A0%91-%EC%A1%B0%EC%9E%91%ED%95%98%EA%B8%B0.html", "categories": "jekyll, update", "tags": "", "date": "2025-06-23 18:26:27 +0900", "content": "“Next.js에서 클라이언트와 서버 사이의 경계를 무너뜨리는 방법이 있을까?”Server Action을 활용하면 가능합니다. 오늘은 이 기능에 대해 알기 쉽게 정리해봅니다. 🔍 Server Action이란?Server Action은 Next.js 13/14에서 도입된 기능으로,서버에서만 실행되는 비동기 함수입니다.클라이언트에서 fetch()로 API를 호출하는 대신,Next 서버 내부 함수를 직접 호출할 수 있습니다.서버에서만 실행되므로, DB 작업, 파일 시스템 접근 등 보안에 민감한 로직을 감출 수 있습니다. 📌 핵심 요약”use server” 디렉티브를 붙인 함수는 브라우저에서 직접 호출되지 않고, 서버에서 실행됩니다. 🛠️ Server Action 사용 방법✅ 예제 코드 // app/actions.ts ‘use server’; export async function createReviewAction(data: FormData) { const content = data.get(“content”); // 데이터베이스 저장 등의 작업 } // app/page.tsx 또는 클라이언트 컴포넌트 &lt;form action={createReviewAction}&gt; Submit &lt;/form&gt; 이처럼 &lt;form&gt;의 action 속성에 서버 액션을 넣으면,폼 제출 시 브라우저는 JS 없이도 서버에 데이터를 전송합니다. ✅ Server Action의 장점 3가지 장점 설명 1️⃣ 서버와의 직접 연결 클라이언트에서 API 호출 없이 Next 서버에서 DB를 직접 조작 2️⃣ 보안성 향상 액션 함수는 브라우저에 포함되지 않아, 민감한 로직이 노출되지 않음 3️⃣ JS 없는 환경 대응 기반이므로, JS 비활성 상태에서도 폼 동작 가능 📌 개발 시 유의사항함수에는 반드시 \"use server\" 선언이 필요합니다.​전달/리턴 가능한 값은 직렬화 가능한 데이터만 가능합니다 (string, number, FormData, 등).​보안 처리는 반드시 별도로 해야 하며, zod나 joi를 활용해 입력 검증을 권장합니다.​Next.js의 revalidatePath()를 활용해 액션 이후 캐시 무효화도 고려해야 합니다. 🔗 참고 링크https://codingapple.com/unit/nextjs-server-actions/ Next.js의 Server actions 기능 - 코딩애플 온라인 강좌 0:00 server actions 쓰는 법 4:18 client component에서 쓰려면 5:27 심심해서 DB에 있던거 출력도 해봄 7:40 폼 전송 후 새로고침하려면 DB에 데이터를 저장, 수정 등을 하고 싶으면 당연히 서버를 거쳐야합니다.  그래서 page.js에 같은 것도 만들고 서버 파일로 이동해서 거기에 API도 작성해놔야하는데 그게 귀찮으면 그냥 page.js 안에서 전부 해결할 수 있는 기능도 있습니다.  Server actions 기능인데 Next.js 13.4 버전 이후부터 사용가능하고 어떻게 쓰는... codingapple.com https://nextjs-ko.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations Server Actions and Mutations – Nextjs 한글 문서 Learn how to handle form submissions and data mutations with Next.js. nextjs-ko.org ​ " }, { "title": "[매일매일]백엔드 기술 일기: 스프링 @Transactional AOP 동작 흐름 완전 정복", "url": "/jekyll/update/2025/06/20/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-%EC%8A%A4%ED%94%84%EB%A7%81-Transactional-AOP-%EB%8F%99%EC%9E%91-%ED%9D%90%EB%A6%84-%EC%99%84%EC%A0%84-%EC%A0%95%EB%B3%B5.html", "categories": "jekyll, update", "tags": "", "date": "2025-06-20 19:42:00 +0900", "content": "안녕하세요, [매일매일] 백엔드 기술일기입니다.오늘은 스프링의 핵심 기능 중 하나인 @Transactional의 동작 흐름을 AOP 기반으로 풀어보려 합니다. 이 개념은 단순히 어노테이션 하나 붙이는 걸 넘어서, 스프링 AOP와 트랜잭션 추상화의 깊은 이해가 필요한 주제입니다. 🧩 핵심 질문 @Transactional 어노테이션은 내부적으로 어떻게 작동하나요? ⚙️ 선언적 트랜잭션 관리란?스프링에서는 @Transactional 어노테이션을 통해 선언적으로 트랜잭션을 관리할 수 있습니다.이는 개발자가 직접 커넥션을 열고, 커밋/롤백하는 코드 없이도 트랜잭션을 안전하게 처리할 수 있도록 도와줍니다. 🛠️ 등장인물 정리1. 트랜잭션 AOP 프록시@Transactional이 붙은 메서드를 감싸는 프록시 객체.실제 서비스 객체를 호출하기 전에 트랜잭션 관련 로직을 먼저 처리함.​2. PlatformTransactionManager (트랜잭션 매니저)스프링이 제공하는 트랜잭션 추상화 인터페이스.대표 구현체:DataSourceTransactionManager (JDBC)JpaTransactionManager (JPA)​3. TransactionSynchronizationManager (트랜잭션 동기화 매니저)현재 스레드에 커넥션을 바인딩하고 관리하는 역할.여러 DAO/Service에서도 같은 트랜잭션 컨텍스트를 공유할 수 있게 해줌. 🔄 전체 동작 흐름 요약클라이언트 요청 → AOP 프록시 → 트랜잭션 시작 → 실제 비즈니스 로직 실행 → 트랜잭션 종료 1. 클라이언트가 서비스 메서드를 호출하면프록시 객체가 가로채서 동작함 (@Transactional 덕분에 AOP 적용됨)​2. 프록시가 PlatformTransactionManager를 통해 트랜잭션 시작내부적으로 커넥션 획득TransactionSynchronizationManager에 바인딩​3. 비즈니스 로직 실행같은 스레드에서 트랜잭션에 참여 중인 DAO/서비스들도 같은 커넥션 사용​4. 정상 종료 시 → 커밋예외 발생 시 → 롤백​5. 트랜잭션 종료 후, 커넥션 반환 및 정리TransactionSynchronizationManager에서 언바인딩 🧪 코드 예시로 이해해보기 @Service public class OrderService { @Transactional public void placeOrder() { saveOrder(); // 내부 DAO 호출 updateInventory(); // 다른 서비스 호출 } } 위 코드에서 @Transactional이 붙은 placeOrder()는 실제로는 AOP 프록시 객체가 감싸게 됩니다.즉, 호출 시 트랜잭션 시작 → 내부 메서드 실행 → 커밋 or 롤백 → 종료의 흐름이 자동 적용됩니다. 💡 트랜잭션 동기화 매니저가 왜 중요할까?TransactionSynchronizationManager는 말 그대로 스레드-로컬(ThreadLocal) 기반의 트랜잭션 공유 관리자입니다.여러 DAO나 레이어에서 동일한 트랜잭션을 사용하게 해줍니다.없었다면?→ 모든 DAO 메서드에 커넥션을 직접 넘겨줘야 했을 것! // 내부적으로는 이렇게 작동함 Connection conn = DataSource.getConnection(); TransactionSynchronizationManager.bindResource(dataSource, conn); 📚 추천 참고 자료🎥 [10분 테코톡] 리차드의 @Transactional: 선언형 트랜잭션 입문자용 영상🎥 [10분 테코톡] 기론, 리버의 JDK Proxy vs CGLIB📄 [Spring 공식 문서] AOP와 트랜잭션📘 테코블 블로그 - AOP 입문자를 위한 개념 이해하기📘 자바 트랜잭션 정복기 (전문 개발자 필독) ✅ 한 눈에 요약 구성 요소 역할 AOP 프록시 @Transactional 메서드 감싸기 트랜잭션 매니저 트랜잭션 시작/종료 책임 (JDBC/JPA에 따라 선택) 동기화 매니저 스레드 기반 커넥션 공유로 트랜잭션 일관성 유지 ✍️ 마무리@Transactional은 개발자를 편하게 만들어주는 강력한 기능이지만, 내부 구조를 이해하고 있어야 예외 처리, 롤백 조건, 트랜잭션 전파 속성 등을 정확히 다룰 수 있습니다.앞으로도 실무에서 흔히 접하는 AOP + 트랜잭션 구조를 익혀두고, 필요한 순간에 정확히 적용해보세요. 🏷️ 태그#Spring #@Transactional #AOP #TransactionManager #스프링트랜잭션 #백엔드개발 " }, { "title": "[매일매일]프론트엔드 기술일기: JS 함수에서 참조가 바뀌면 어떤 일이 일어날까?", "url": "/jekyll/update/2025/06/20/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0%EC%9D%BC%EA%B8%B0-JS-%ED%95%A8%EC%88%98%EC%97%90%EC%84%9C-%EC%B0%B8%EC%A1%B0%EA%B0%80-%EB%B0%94%EB%80%8C%EB%A9%B4-%EC%96%B4%EB%96%A4-%EC%9D%BC%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%A0%EA%B9%8C.html", "categories": "jekyll, update", "tags": "", "date": "2025-06-20 19:38:20 +0900", "content": "이번 포스트에서는 Call by Value, Call by Reference, Call by Sharing 개념을 예제 기반으로 명확하게 정리합니다.​안녕하세요, [매일매일] 기술일기입니다.오늘은 자바스크립트 함수 호출 방식인 Call by Value, Call by Reference, 그리고 Call by Sharing 개념을 다룰 거예요.​예제를 먼저 살펴보고, 어떤 값이 왜 바뀌었는지 차근차근 분석해보겠습니다.이번 정리는 매일메일 문제와 함께, 직접 실습한 예제를 바탕으로 정리해봅니다.​💻 예제 코드 function change(a, b, c) { a = ‘a changed’ b = { b: ‘changed’ }; c.c = ‘changed’; } let a = ‘a unchanged’; let b = { b: ‘unchanged’ }; let c = { c: ‘unchanged’ }; change(a, b, c); console.log(a, b, c); // ? ​🔍 실행 결과 // 결과 출력 “a unchanged” { b: “unchanged” } { c: “changed” } ​🧠 왜 이렇게 나올까? — 파라미터 전달 방식의 차이자바스크립트는 함수에 인자를 넘길 때 모두 Call by Value 방식으로 처리합니다.하지만 값의 “종류”가 원시 타입인지 객체인지에 따라 동작 방식이 달라집니다. 1️⃣ a = ‘a unchanged’ (문자열 - 원시값)a는 문자열이므로 값 자체의 복사본이 함수로 전달됩니다.함수 안에서 a = ‘a changed’를 해도, 복사된 값만 바뀌고 원본에는 영향을 주지 않습니다.🧾 결과: 그대로 “a unchanged” 2️⃣ b = { b: ‘unchanged’ } (객체 - 참조형)객체는 참조값(주소)의 복사본이 전달됩니다.하지만 함수 안에서 b = { b: ‘changed’ }처럼 새 객체를 할당하면,→ 함수 안의 b는 완전히 새로운 참조를 갖게 됨→ 외부의 b에는 영향이 없음🧾 결과: 여전히 { b: ‘unchanged’ } 3️⃣ c = { c: ‘unchanged’ } (객체 - 참조형)c도 참조형이지만, 이번엔 객체의 속성만 변경합니다: c.c = ‘changed’이 경우는 같은 객체의 속성을 바꾸는 것이므로 외부에서도 변경이 반영됩니다.🧾 결과: { c: ‘changed’ } 🔑 요약 정리​ 항목 전달 방식 함수 내 변경 방식 외부에 영향 있음? 결과 a Call by Value (원시값 복사) a = ‘a changed’ (재할당) ❌ “a unchanged” b 참조값 복사 b = { b: ‘changed’ } (새 객체 할당) ❌ { b: ‘unchanged’ } c 참조값 복사 c.c = ‘changed’ (속성 변경) ✅ { c: ‘changed’ } 🧪 관련 개념: Call by Value vs. Reference vs. Sharing✅ Call by Value자바스크립트의 기본 방식함수로 넘어가는 건 값의 복사본 (객체는 참조값의 복사본)​✅ Call by Reference값이 아닌 참조 주소 자체를 넘긴다 (JS에는 없음)​✅ Call by Sharing (JS에서 일어나는 실제 방식)참조값(주소)의 복사본을 넘겨서, 내부에서 속성을 변경하면 외부도 영향받음하지만 재할당은 외부에 영향을 주지 않음​ " }, { "title": "[매일매일] 백엔드 기술 일기: “에러가 났을 때 해결하는 능력”은 어떻게 키울 수 있나요?(전략 패턴)", "url": "/jekyll/update/2025/06/19/%EB%A7%A4%EC%9D%BC%EB%A7%A4%EC%9D%BC-%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EC%9D%BC%EA%B8%B0-%EC%97%90%EB%9F%AC%EA%B0%80-%EB%82%AC%EC%9D%84-%EB%95%8C-%ED%95%B4%EA%B2%B0%ED%95%98%EB%8A%94-%EB%8A%A5%EB%A0%A5-%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%82%A4%EC%9A%B8-%EC%88%98-%EC%9E%88%EB%82%98%EC%9A%94-%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4.html", "categories": "jekyll, update", "tags": "", "date": "2025-06-19 17:41:00 +0900", "content": "​ 매일 아침 ☀️ ‘매일메일’에서 받은 질문 #177을 학습·정리해 블로그에 기록합니다.오늘 주제는 “에러 해결 능력은 어떻게 키우나요?” 입니다. 전략 패턴이란?​전략 패턴(Strategy Pattern) 은 객체의 행위를 동적으로 변경하고 싶은 경우, 코드를 직접 수정하는 것이 아닌 추상화된 전략의 구현만을 바꿔 객체의 행위를 변경하는 디자인 패턴입니다. 자바 언어의 요소와 함께 설명해 드리자면, 객체의 행위를 Interface로 정의하고, Interface의 메서드를 구현하는 구현체들을 주입하는 것이 전략 패턴의 대표적인 형태입니다. class Car { private final MoveStrategy strategy; private final int position; public Car(MoveStrategy strategy, int position) { this.strategy = strategy; this.position = position; } public Car move(int input) { if(strategy.isMovable(input)) { return new Car(strategy, car + 1); } return this; } } interface MoveStrategy { boolean isMovable(int input); } class EvenNumberMoveStrategy implements MoveStrategy { @Override public boolean isMovable(int input) { return (input % 2) == 0; } } class OddNumberMoveStrategy implements MoveStrategy { … } class PrimeNumberMoceStrategy implements MoveStrategy { … } 1️⃣ 핵심 한 줄 요약에러 해결 능력은 “읽기 + 추측 + 실험”의 반복에서 자라납니다. 구글링도 기술이고, 디버깅도 훈련입니다. 2️⃣ 에러 해결의 3단계 루틴 단계 설명 팁 에러 로그를 읽는다 콘솔/터미널/브라우저 등에서 빨간 글씨를 두려워하지 않기 at line XX → 위치 확인, ReferenceError 같은 키워드 먼저 파악 키워드 중심으로 구글링 에러 메시지 복붙보다는 핵심 단어 위주 검색 “Cannot read properties of undefined” + 라이브러리 이름 실험하고 좁혀간다 코드를 한 줄씩 주석처리/변형해가며 원인 찾기 Git 커밋을 자주 남겨 실험 단위 분리 3️⃣ 실전 예시❌ TypeError: Cannot read properties of undefined (reading ‘map’) // 잘못된 코드 예시 export default function UserList({ users }) { return ( &lt;ul&gt; {users.map((user) =&gt; ( &lt;li key={user.id}&gt;{user.name}&lt;/li&gt; ))} &lt;/ul&gt; ); } // 이 코드에서 users가 undefined일 경우 ‘map’을 쓸 수 없어 에러 발생 ✔️ 해결 과정 // 1. 초기값 확인 (예: props 또는 상태 초기화) const [users, setUsers] = useState([]); // ✅ 빈 배열로 초기화 // 또는 부모 컴포넌트에서 전달 시 props 기본값 설정 UserList.defaultProps = { users: [], }; // 2. 조건부 렌더링 export default function UserList({ users }) { return ( &lt;ul&gt; {Array.isArray(users) &amp;&amp; users.map((user) =&gt; ( &lt;li key={user.id}&gt;{user.name}&lt;/li&gt; ))} &lt;/ul&gt; ); } 4️⃣ 에러 해결 능력 키우는 습관✅ Stack Overflow 활용법: 질문 제목은 최대한 구체적으로, 코드 포함은 필수​✅ ChatGPT 활용법: “내 코드 전체가 아니라 의심되는 블록만 올려 설명”​✅ 실전 에러 로그 아카이브 만들기:​Notion이나 블로그에 “나만의 에러 사전” 작성​“무엇이 원인이었고, 어떻게 해결했는지” 중심으로 정리 5️⃣ Today’s Takeaways​에러는 “피할 것”이 아니라 “읽고 대화할 대상”이다.​에러는 내 실수를 찝어주는 AI 조교라고 생각해보자.​해결력이 뛰어난 개발자는 코드를 완벽히 짜는 사람이 아니라, 에러를 빠르게 추적하는 사람이다. ✍🏻 마무리 메모처음에는 막막하지만,하루에 하나씩 ‘읽고 해결해본 에러’를 기록해보면조만간 구글 검색어가 날카로워지고, 로그만 봐도 방향이 보이기 시작할 거예요.내일도 한 걸음씩 성장하기 위해,[매일매일] 카테고리에서 함께 학습해요! 😊 참고 자료 및 출처https://victorydntmd.tistory.com/292 [디자인패턴] 전략 패턴 ( Strategy Pattern ) 전략 패턴 ( Strategy Pattern )객체들이 할 수 있는 행위 각각에 대해 전략 클래스를 생성하고, 유사한 행위들을 캡슐화 하는 인터페이스를 정의하여,객체의 행위를 동적으로 바꾸고 싶은 경우 직접 행위를 수정하지 않고 전략을 바꿔주기만 함으로써 행위를 유연하게 확장하는 방법을 말합니다.간단히 말해서 객체가 할 수 있는 행위들 각각을 전략으로 만들어 놓고, 동적으로 행위의 수정이 필요한 경우 전략을 바꾸는 것만으로 행위의 수정이 가능하도록 만든 패턴입니다.   01. 전략 패턴 사용 이유예를 들어, 기차( Train )와 … victorydntmd.tistory.com https://www.youtube.com/watch?v=vNsZXC3VgUA https://www.youtube.com/watch?v=hL0gdGJgI4k https://www.maeil-mail.kr/question/177 매일메일 - 전략 패턴에 대해서 설명해주세요. 전략 패턴(Strategy Pattern) 은 객체의 행위를 동적으로 변경하고 싶은 경우, 코드를 직접 수정하는 것이 아닌 추상화된 전략의 구현만을 바꿔 객체의 행위를 변경하는 디자인 패턴입니다. 자바 언어의 요소와 함께 설명해 드리자면, 객체의 행위를 Interface로 정의하고, Interface의 메서드를 구현하는 구현체들을 주입하는 것이 전략 패턴의 대표적인 형태입니다. ```java class Car { private final MoveStrategy strategy; private final int position… www.maeil-mail.kr ​ " }, { "title": "오늘의 트렌드", "url": "/2025/04/26/today-trends.html", "categories": "", "tags": "", "date": "2025-04-26 09:00:00 +0900", "content": "오늘의 트렌드 " }, { "title": "테스트", "url": "/2025/04/26/%ED%85%8C%EC%8A%A4%ED%8A%B8.html", "categories": "", "tags": "", "date": "2025-04-26 00:00:00 +0900", "content": " " }, { "title": "Hello 71stars", "url": "/2025/04/26/hello-71stars.html", "categories": "", "tags": "", "date": "2025-04-26 00:00:00 +0900", "content": "처음으로 올리는 글입니다! ✨ " }, { "title": "Customize the Favicon", "url": "/blogging/tutorial/2019/08/11/customize-the-favicon.html", "categories": "Blogging, Tutorial", "tags": "favicon", "date": "2019-08-11 01:34:00 +0900", "content": "The favicons of Chirpy are placed in the directory assets/img/favicons/. You may want to replace them with your own. The following sections will guide you to create and replace the default favicons. Generate the favicon Prepare a square image (PNG, JPG, or SVG) with a size of 512x512 or more, and then go to the online tool Real Favicon Generator and click the button Select your Favicon image to upload your image file. In the next step, the webpage will show all usage scenarios. You can keep the default options, scroll to the bottom of the page, and click the button Generate your Favicons and HTML code to generate the favicon. Download &amp; Replace Download the generated package, unzip and delete the following two from the extracted files: browserconfig.xml site.webmanifest And then copy the remaining image files (.PNG and .ICO) to cover the original files in the directory assets/img/favicons/ of your Jekyll site. If your Jekyll site doesn’t have this directory yet, just create one. The following table will help you understand the changes to the favicon files: File(s) From Online Tool From Chirpy *.PNG ✓ ✗ *.ICO ✓ ✗ ✓ means keep, ✗ means delete. The next time you build the site, the favicon will be replaced with a customized edition. " }, { "title": "Getting Started", "url": "/blogging/tutorial/2019/08/09/getting-started.html", "categories": "Blogging, Tutorial", "tags": "getting started", "date": "2019-08-09 21:55:00 +0900", "content": "Get started with Chirpy basics in this comprehensive overview. You will learn how to install, configure, and use your first Chirpy-based website, as well as deploy it to a web server." }, { "title": "Text and Typography", "url": "/blogging/demo/2019/08/08/text-and-typography.html", "categories": "Blogging, Demo", "tags": "typography", "date": "2019-08-08 12:33:00 +0900", "content": "Examples of text, typography, math equations, diagrams, flowcharts, pictures, videos, and more." } ]
